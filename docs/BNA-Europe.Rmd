---
title: "BNA score for Europe"
subtitle: An attempt to reproduce the People for Bikes BNA score
author: Lorena Abad
output: 
  html_notebook:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: journal
    code_folding: hide
    df_print: tibble
---
[![GitHub](Figures/GitHub-Mark-32px.png "Click here to redirect to my repository")](https://github.com/loreabad6/masters-thesis-geotech) 

*Check out my github repository for more content and updates on this project.*

The codes below will allow the computation of the [BNA score](https://bna.peopleforbikes.org/#/) for any city in Europe. The coding languages are a combination of R and SQL, with a few lines passed onto the Command Prompt.

# Case study: Cambridge, UK {.tabset}

## Workflow step by step 

### 1. Establish a connection with the PostgreSQL server and establish basic parameters of analysis.

Within this step, three major things are performed, assuming that the user has created a database on its PostgreSQL. To test connection an empty table on the database called "test" was created on the public schema.

#### - Create connection and test it

```{r, include = FALSE, warning = FALSE}
start <- Sys.time()
```


```{r, include = FALSE}
db_name = "bna_europe"
local_host = "localhost"
port_num = 5432
user_name = "postgres"
```

```{r, echo = TRUE, include = TRUE, warning = FALSE}
library(RPostgreSQL)

# LOAD POSTGRESQL DRIVER
driver <- dbDriver("PostgreSQL")
# CREATE CONNECTION TO THE POSTGRESQL DATABASE
# THE CONNECTION VARIABLE WILL BE USED FOR ALL FURTHER OPERATIONS
connection <- dbConnect(
  driver, 
  dbname = db_name,
  host = local_host, 
  port = port_num,
  user = user_name, 
  password = rstudioapi::askForPassword("Database password")
)

ifelse(
  !dbExistsTable(connection, "test"),
  "The connection to the database was not possible.",
  "The connection to the database was successful!"
)

# DISCONNECT: Important when modifying the database on pgadmin4
# dbDisconnect(connection)
```

#### - Set up database

```{sql, connection = connection, echo = TRUE}
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS pgrouting;
CREATE SCHEMA IF NOT EXISTS destinations;
CREATE SCHEMA IF NOT EXISTS generated;
CREATE SCHEMA IF NOT EXISTS received;
```

#### - Establish Study Area and other important variables

Not only the name of the study area should be established, but also the number of subdivisions for the grid, the coordinate reference system to work with, and the biking distance that will be assumed for the connectivity analysis. 

```{r, warning = FALSE}
sa_name = "Cambridge"
subdivisions = 4
sa_crs = 3857
biking_distance = 3000 ## in meters
paste("You are running the BNA score for", sa_name, "within a biking distance of", biking_distance/1000, "km.")
```

### 2. Obtain study area boundary with `osmdata`.

Extract the study area boundary considering a buffer of half the biking distance established. 

```{r, echo = TRUE, include = TRUE, warning = FALSE}
# FUNCTION TO EXTRACT STUDY AREA BOUNDARY WITH OSM AND WRITE IT TO THE DATABASE
sa_bb <- function (study_area, dist, crs, conn){
  # GET DATA FROM OSM
  library(osmdata)
  library(sf)
  study_area_bb <- study_area %>% 
    getbb(format_out = "sf_polygon") %>%
    st_transform(crs = crs)
  
  ## ADD A BUFFER TO THE BOUNDARY
  study_area_bb <-study_area_bb %>% 
    st_buffer(dist = 0.5*dist)
  
  # DELETE EXISTING BOUNDARY
  library(sqldf)
  sqldf(
    "DROP TABLE IF EXISTS received.sa_boundary",
    connection = conn
  )

  # UPLOAD BOUNDARY TO POSTGRESQL DATABASE
  library(RPostgreSQL)
  dbWriteTable(conn, c("received","sa_boundary"), study_area_bb)
  
  study_area_bb
}

boundary <- sa_bb(
  study_area = sa_name, 
  dist = biking_distance,
  crs = sa_crs, 
  conn = connection
)
```

```{r, fig.width = 8, fig.height= 8, echo = TRUE, warning = FALSE}
library(tmap)
tmap_mode("view")
qtm(
  shp = boundary, 
  fill = NULL, 
  borders = "red", 
  basemaps = "OpenStreetMap"
)
```

### 3. Obtain the `.osm` file from **Overpass API**

```{r, warning = FALSE}
# FUNCTION TO DOWNLOAD OSM DATA WITH THE OVERPASS API 
sa_download <- function(conn){
  # OBTAIN THE EXTENT OF THE STUDY AREA AS A BOUNDING BOX
  sa_extent <- dbGetQuery(conn,
        "SELECT
        ST_Extent((ST_Transform(geometry,4326)))
        FROM received.sa_boundary") 
  
  library(stringr)
  sa_coord <- toString(sa_extent) %>% 
    str_extract_all("\\-*\\d+\\.*\\d*") %>% 
    unlist() %>% 
    toString()
    
  # CONSTRUCT THE API LINE TO REQUEST THE DATA
  api <- paste(
    'https://overpass-api.de/api/map?bbox=',
    sa_coord,
    sep = ''
  )
  
  # CREATE A NEW TEMPORAL DIRECTORY TO DOWNLOAD THE INFO
  cd <- getwd()
  ifelse(
    !file.exists(file.path(cd,'temp')),
    dir.create(file.path(cd,'temp')), 
    "Directory already exists"
  )
  
  # ESTABLISH THE NAME OF THE FILE WHERE THE OVERPASS API WILL DOWNLOAD ITS DATA
  osm_file <- file.path(cd,'temp','overpass.osm')
  
  # REQUEST THE DATA FROM THE API
  library(utils)
  download.file(url = api, destfile = osm_file, extra = '-nv -O') 
  
  ifelse(
    file.exists(file.path(cd,'temp','overpass.osm')),
    "OMS data successfully downloaded!",
    "OSM data was not downloaded, please try again or download manually."
  )
  
}

# DOWNLOAD THE DATA FROM OSM WITH OVERPASS API
sa_download(conn = connection)
```

### 4. Load data into the PostgreSQL database. 

#### - Obtain configuration files

```{r, collapse = TRUE, warning = FALSE}
# CREATE A NEW TEMPORAL DIRECTORY TO DOWNLOAD THE INFO
cd <- getwd()
ifelse(
  !file.exists(file.path(cd,'temp')),
  dir.create(file.path(cd,'temp')), 
  "Directory already exists"
)

# ESTABLISH THE NAME OF THE FILES 
pfbstyle_file <- file.path(cd,'temp','pfb.style')
mapconfig_file <- file.path(cd,"temp","mapconfig.xml")
mapconfigbikes_file <- file.path(cd,"temp","mapconfig_for_bicycles.xml")

# CHECK IF THEY ARE DOWNLOADED
if(
  file.exists(file.path(pfbstyle_file)) & 
  file.exists(file.path(mapconfig_file)) &
  file.exists(file.path(mapconfigbikes_file))
){
  "Files are already downloaded!"
} else {
 # ESTABLISH THE URLS
  pfbstyle_url <- "https://raw.githubusercontent.com/azavea/pfb-network-connectivity/develop/src/analysis/import/pfb.style"
  
  mapconfig_url <- "https://raw.githubusercontent.com/pgRouting/osm2pgrouting/master/mapconfig.xml"
  
  mapconfigbikes_url <- 
  "https://raw.githubusercontent.com/pgRouting/osm2pgrouting/master/mapconfig_for_bicycles.xml"
  
  # REQUEST THE DATA
  library(utils)
  download.file(url = pfbstyle_url, destfile = pfbstyle_file)
  download.file(url = mapconfig_url, destfile = mapconfig_file)
  download.file(url = mapconfigbikes_url, destfile = mapconfigbikes_file) 
}
```


#### - Load data with `osm2pgsql` and `osm2pgrouting`

**NOTE:** To run this command [set path variables](https://learnosm.org/en/osm-data/osm2pgsql/) for `osm2pgsql` and `osm2pgrouting` and [create a password file](https://www.postgresql.org/docs/9.1/libpq-pgpass.html) on %APPDATA%/postgresql/pgpass.conf with the format hostname:port:database:username:password.

```{r, include = FALSE, warning = FALSE}
system(
  command = "osm2pgsql -c -d bna_europe -U postgres -H localhost -W --create --prefix sa_full -S E:/GeoTech/Thesis/Thesis_R_Project/temp/pfb.style E:/GeoTech/Thesis/Thesis_R_Project/temp/overpass.osm --cache 600",
  show.output.on.console = TRUE
  )

system(
  command = "osm2pgrouting -f E:/GeoTech/Thesis/Thesis_R_Project/temp/overpass.osm -h localhost -d bna_europe --username postgres --schema received --prefix sa_all_ --conf E:/GeoTech/Thesis/Thesis_R_Project/temp/mapconfig.xml --clean",
  show.output.on.console = TRUE
)

system(
  command = "osm2pgrouting -f E:/GeoTech/Thesis/Thesis_R_Project/temp/overpass.osm -h localhost  -d bna_europe --username postgres --schema received --prefix sa_bike_ --conf E:/GeoTech/Thesis/Thesis_R_Project/temp/mapconfig_for_bicycles.xml --clean",
  show.output.on.console = TRUE
)
```

Replace variables between `%`:

```{r, echo = TRUE, eval = FALSE, include = TRUE, warning = FALSE}
system(
  command = "osm2pgsql -c -d %DBNAME% -U %USERNAME% -H %HOSTNAME% -W --create --prefix sa_full -S %CURRENTDIRECTORY/temp/pfb.style% %CURRENTDIRECTORY/temp/overpass.osm% --cache 600",
  show.output.on.console = TRUE
  )

system(
  command = "osm2pgrouting -f %CURRENTDIRECTORY/temp/overpass.osm% -h %HOSTNAME% --password %DBPASSWORD% -d %DBNAME% --username %USERNAME% --schema received --prefix sa_all_ --conf %CURRENTDIRECTORY/temp/mapconfig.xml% --clean",
  show.output.on.console = TRUE
)

system(
  command = "osm2pgrouting -f %CURRENTDIRECTORY/temp/overpass.osm% -h %HOSTNAME% --password %DBPASSWORD% -d %DBNAME% --username %USERNAME% --schema received --prefix sa_bike_ --conf %CURRENTDIRECTORY/temp/mapconfig_for_bicycles.xml% --clean",
  show.output.on.console = TRUE
)
```

### 5. Organize and prepare the database 

On this step, several SQL queries are being run to organize the tables, clip them to the study area outline, merge it with the *osm2pgsql* data among other things. The scripts include mainly the code that PfB already uses, but with some modifications like changing feet to meters, mph to km/h, and others. Basically, 4 steps are taken:

#### - Organize tables

Which drops unused columns and projects data to the already established CRS. It also cleans the database for a new analysis to be run if the study area is changed for example. 

```{sql, connection = connection, output.var = "output", include = FALSE}

-- ORGANIZE NEWLY CREATED TABLES

-- delete existing tables

DROP TABLE IF EXISTS received.sa_full_line;
DROP TABLE IF EXISTS received.sa_full_point;
DROP TABLE IF EXISTS received.sa_full_polygon;
DROP TABLE IF EXISTS received.sa_full_roads;
DROP TABLE IF EXISTS received.sa_ways;
DROP TABLE IF EXISTS received.sa_ways_int;

-- move tables to received schema
ALTER TABLE IF EXISTS public.sa_full_line SET SCHEMA received;
ALTER TABLE IF EXISTS public.sa_full_point SET SCHEMA received;
ALTER TABLE IF EXISTS public.sa_full_polygon SET SCHEMA received;
ALTER TABLE IF EXISTS public.sa_full_roads SET SCHEMA received;

-- drop unused tables
DROP TABLE IF EXISTS received.sa_all_pointsofinterest;
DROP TABLE IF EXISTS received.sa_bike_pointsofinterest;

-- drop unused columns
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS tag_id;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS length;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS length_m;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS x1;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS y1;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS x2;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS y2;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS cost;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS reverse_cost;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS cost_s;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS reverse_cost_s;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS rule;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS maxspeed_forward;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS maxspeed_backward;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS source_osm;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS target_osm;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS priority;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS one_way;
ALTER TABLE IF EXISTS received.sa_all_ways DROP COLUMN IF EXISTS oneway;

ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS cnt;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS chk;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS ein;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS eout;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS lon;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr DROP COLUMN IF EXISTS lat;

-- change column names
ALTER TABLE IF EXISTS received.sa_all_ways RENAME COLUMN gid TO road_id;
ALTER TABLE IF EXISTS received.sa_all_ways RENAME COLUMN the_geom TO geom;
ALTER TABLE IF EXISTS received.sa_all_ways RENAME COLUMN source TO intersection_from;
ALTER TABLE IF EXISTS received.sa_all_ways RENAME COLUMN target TO intersection_to;

ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr RENAME COLUMN id TO int_id;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr RENAME COLUMN the_geom TO geom;

-- change names of tables
ALTER TABLE IF EXISTS received.sa_all_ways RENAME TO sa_ways;
ALTER TABLE IF EXISTS received.sa_all_ways_vertices_pgr RENAME TO  sa_ways_int;

-- create new columns

ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS functional_class TEXT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS path_id INTEGER;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS speed_limit INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS one_way_car VARCHAR(2);
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS one_way VARCHAR(2);
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS width INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_bike_infra TEXT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_bike_infra_width FLOAT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_bike_infra TEXT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_bike_infra_width FLOAT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_lanes INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_lanes INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_cross_lanes INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_cross_lanes INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS twltl_cross_lanes INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_park INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_park INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_seg_stress INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS ft_int_stress INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_seg_stress INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS tf_int_stress INT;
ALTER TABLE IF EXISTS received.sa_ways ADD COLUMN IF NOT EXISTS xwalk INT;

ALTER TABLE IF EXISTS received.sa_ways_int ADD COLUMN IF NOT EXISTS legs INT;
ALTER TABLE IF EXISTS received.sa_ways_int ADD COLUMN IF NOT EXISTS signalized BOOLEAN;
ALTER TABLE IF EXISTS received.sa_ways_int ADD COLUMN IF NOT EXISTS stops BOOLEAN;
ALTER TABLE IF EXISTS received.sa_ways_int ADD COLUMN IF NOT EXISTS rrfb BOOLEAN;
ALTER TABLE IF EXISTS received.sa_ways_int ADD COLUMN IF NOT EXISTS island BOOLEAN;

-- indexes
DROP INDEX IF EXISTS received.idx_sa_ways_osm;
DROP INDEX IF EXISTS received.idx_sa_ways_int_osm;
DROP INDEX IF EXISTS received.idx_sa_all_fullways;
DROP INDEX IF EXISTS received.idx_sa_all_fullpoints;
CREATE INDEX idx_sa_ways_osm ON received.sa_ways (osm_id);
CREATE INDEX idx_sa_ways_int_osm ON received.sa_ways_int (osm_id);
CREATE INDEX idx_sa_all_fullways ON received.sa_full_line (osm_id);
CREATE INDEX idx_sa_all_fullpoints ON received.sa_full_point (osm_id);

ANALYZE received.sa_ways (osm_id,geom);
ANALYZE received.sa_bike_ways (the_geom);
ANALYZE received.sa_ways_int (osm_id);
ANALYZE received.sa_full_line (osm_id);
ANALYZE received.sa_full_point (osm_id);

-- add in cycleway data that is missing from first osm2pgrouting call
INSERT INTO received.sa_ways (
    name, intersection_from, intersection_to, osm_id, geom
)
SELECT  name,
        (SELECT     i.int_id
        FROM        received.sa_ways_int i
        WHERE       i.geom <#> received.sa_bike_ways.the_geom < 20
        ORDER BY    ST_Distance(ST_StartPoint(received.sa_bike_ways.the_geom),i.geom) ASC
        LIMIT       1),
        (SELECT     i.int_id
        FROM        received.sa_ways_int i
        WHERE       i.geom <#> received.sa_bike_ways.the_geom < 20
        ORDER BY    ST_Distance(ST_EndPoint(received.sa_bike_ways.the_geom),i.geom) ASC
        LIMIT       1),
        osm_id,
        the_geom
FROM    received.sa_bike_ways
WHERE   NOT EXISTS (
            SELECT  1
            FROM    received.sa_ways w2
            WHERE   w2.osm_id = received.sa_bike_ways.osm_id
);

DROP INDEX IF EXISTS received.idx_sa_ways_ints_stop;
DROP INDEX IF EXISTS received.idx_sa_ways_rrfb;
DROP INDEX IF EXISTS received.idx_sa_ways_island;
CREATE INDEX idx_sa_ways_ints_stop ON received.sa_ways_int (signalized,stops);
CREATE INDEX idx_sa_ways_rrfb ON received.sa_ways_int (rrfb);
CREATE INDEX idx_sa_ways_island ON received.sa_ways_int (island);

ALTER TABLE IF EXISTS received.sa_ways ALTER COLUMN geom TYPE geometry(linestring,?sa_crs)
USING ST_Transform(geom,?sa_crs);
ALTER TABLE IF EXISTS received.sa_bike_ways ALTER COLUMN the_geom TYPE geometry(linestring,?sa_crs)
USING ST_Transform(the_geom,?sa_crs);
ALTER TABLE IF EXISTS received.sa_ways_int ALTER COLUMN geom TYPE geometry(point,?sa_crs)
USING ST_Transform(geom,?sa_crs);
ALTER TABLE IF EXISTS received.sa_full_line ALTER COLUMN way TYPE geometry(linestring,?sa_crs)
USING ST_Transform(way,?sa_crs);
ALTER TABLE IF EXISTS received.sa_full_point ALTER COLUMN way TYPE geometry(point,?sa_crs)
USING ST_Transform(way,?sa_crs);
ALTER TABLE IF EXISTS received.sa_full_polygon ALTER COLUMN way TYPE geometry(polygon,?sa_crs)
USING ST_Transform(way,?sa_crs);
ALTER TABLE IF EXISTS received.sa_full_roads ALTER COLUMN way TYPE geometry(linestring,?sa_crs)
USING ST_Transform(way,?sa_crs);

SELECT * FROM received.sa_full_roads;

```

#### - Clip data into boundary

Which clips the data into the boundary of the study area selected.

```{sql, connection = connection, output.var = "output", include = FALSE}

ALTER TABLE IF EXISTS received.sa_ways DROP CONSTRAINT IF EXISTS sa_all_ways_source_fkey CASCADE;
ALTER TABLE IF EXISTS received.sa_ways DROP CONSTRAINT IF EXISTS sa_all_ways_target_fkey CASCADE;

DELETE FROM received.sa_ways_int AS intersections
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(intersections.geom, boundary.geometry, 1000);

DELETE FROM received.sa_ways AS ways
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(ways.geom, boundary.geometry, 1000);

DELETE FROM received.sa_full_line AS lines
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(lines.way, boundary.geometry, 1000);

DELETE FROM received.sa_full_point AS points
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(points.way, boundary.geometry, 1000);

DELETE FROM received.sa_full_polygon AS polygons
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(polygons.way, boundary.geometry, 1000);

DELETE FROM received.sa_full_roads AS roads
    USING received.sa_boundary AS boundary
    WHERE NOT ST_DWithin(roads.way, boundary.geometry, 1000);
    
SELECT * FROM received.sa_full_roads;
```

#### - Populate way table

Which does modifications to the following columns on the ways table:

##### > one way

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET one_way_car = NULL;

-- ft direction
UPDATE  received.sa_ways
SET     one_way_car = 'ft'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     trim(osm.oneway) IN ('1','yes');

-- tf direction
UPDATE  received.sa_ways
SET     one_way_car = 'tf'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     trim(osm.oneway) = '-1';

```

##### > width

```{sql, connection = connection, include = FALSE}

UPDATE  received.sa_ways SET width = NULL;

-- feet
UPDATE  received.sa_ways
SET     width = substring(osm.width from '\d+\.?\d?\d?')::FLOAT/3.28084
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.width IS NOT NULL
AND     osm.width LIKE '% ft';

-- meters
UPDATE  received.sa_ways
SET     width = substring(osm.width from '\d+\.?\d?\d?')::FLOAT
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.width IS NOT NULL
AND     osm.width LIKE '% m';

-- no units (default=meters)
UPDATE  received.sa_ways
SET     width = substring(osm.width from '\d+\.?\d?\d?')::FLOAT
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.width IS NOT NULL
AND     substring(osm.width from '\d+\.?\d?\d?')::FLOAT < 20;

-- Things changed: I'd rather have width in meters, so I changed all the conversion factors.
```

##### > functional class

```{sql, connection = connection, include = FALSE}

UPDATE  received.sa_ways SET functional_class = NULL;

UPDATE  received.sa_ways
SET     functional_class = osm.highway
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway IN (
            'motorway',
            'tertiary',
            'trunk',
            'tertiary_link',
            'motorway_link',
            'secondary_link',
            'primary_link',
            'trunk_link',
            'unclassified',
            'residential',
            'secondary',
            'primary',
            'living_street'
);

UPDATE  received.sa_ways
SET     functional_class = 'track'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway = 'track'
AND     osm.tracktype = 'grade1';

UPDATE  received.sa_ways
SET     functional_class = 'path'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway IN ('cycleway','path');

UPDATE  received.sa_ways
SET     functional_class = 'path',
        xwalk = 1
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway = 'footway'
AND     osm.footway = 'crossing';

UPDATE  received.sa_ways
SET     functional_class = 'path'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway = 'footway'
AND     osm.bicycle = 'designated'
AND     (osm.access IS NULL OR osm.access NOT IN ('no','private'))
AND     COALESCE(received.sa_ways.width,0) >= 8;

UPDATE  received.sa_ways
SET     functional_class = 'path'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway='service'
AND     osm.bicycle='designated';

UPDATE  received.sa_ways
SET     functional_class = 'living_street'
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     osm.highway = 'pedestrian'
AND     osm.bicycle IN ('yes','permissive', 'designated')
AND     (osm.access IS NULL OR osm.access NOT IN ('no','private'));

-- remove stuff that we don't want to route over
DELETE FROM received.sa_ways WHERE functional_class IS NULL;

-- remove orphans
DELETE FROM received.sa_ways
WHERE   NOT EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   received.sa_ways.intersection_to IN (w.intersection_to,w.intersection_from)
            AND     w.road_id != received.sa_ways.road_id
)
AND     NOT EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   received.sa_ways.intersection_from IN (w.intersection_to,w.intersection_from)
            AND     w.road_id != received.sa_ways.road_id
);

-- remove obsolete intersections
DELETE FROM received.sa_ways_int
WHERE NOT EXISTS (
    SELECT  1
    FROM    received.sa_ways w
    WHERE   int_id IN (w.intersection_to,w.intersection_from)
);

```

##### > paths

```{sql, connection = connection, output.var = "output", include = FALSE}

DROP TABLE IF EXISTS generated.sa_paths;
DROP INDEX IF EXISTS received.idx_sa_ways_path_id;

CREATE TABLE generated.sa_paths (
    path_id SERIAL PRIMARY KEY,
    geom geometry(multilinestring, ?sa_crs),
    road_ids INTEGER[],
    path_length INTEGER,
    bbox_length INTEGER
);

-- combine contiguous paths
INSERT INTO generated.sa_paths (geom)
SELECT  ST_CollectionExtract(
            ST_SetSRID(
                unnest(ST_ClusterIntersecting(geom)),
                ?sa_crs
            ),
            2   --linestrings
        )
FROM    received.sa_ways
WHERE   functional_class = 'path';

-- get raw lengths
UPDATE  generated.sa_paths
SET     path_length = ST_Length(geom);

-- get bounding box lengths
UPDATE  generated.sa_paths
SET     bbox_length = ST_Length(
            ST_SetSRID(
                ST_MakeLine(
                    ST_MakePoint(ST_XMin(geom), ST_YMin(geom)),
                    ST_MakePoint(ST_XMax(geom), ST_YMax(geom))
                ),
                ?sa_crs
            )
        );

-- index
CREATE INDEX sidx_sa_paths_geom ON generated.sa_paths USING GIST (geom);
ANALYZE generated.sa_paths (geom);

-- set path_id on each road segment (if path)
UPDATE  received.sa_ways
SET     path_id = (
            SELECT  paths.path_id
            FROM    generated.sa_paths paths
            WHERE   ST_Intersects(received.sa_ways.geom,paths.geom)
            AND     ST_CoveredBy(received.sa_ways.geom,paths.geom)
            LIMIT   1
        )
WHERE   functional_class = 'path';

-- get stragglers
UPDATE  received.sa_ways
SET     path_id = paths.path_id
FROM    generated.sa_paths paths
WHERE   received.sa_ways.functional_class = 'path'
AND     received.sa_ways.path_id IS NULL
AND     ST_Intersects(received.sa_ways.geom,paths.geom)
AND     ST_CoveredBy(received.sa_ways.geom,ST_Buffer(paths.geom,1));

-- set index
CREATE INDEX idx_sa_ways_path_id ON received.sa_ways (path_id);
ANALYZE received.sa_ways (path_id);

-- set road_ids
UPDATE  generated.sa_paths
SET     road_ids = array((
            SELECT  road_id
            FROM    received.sa_ways
            WHERE   received.sa_ways.path_id = generated.sa_paths.path_id
        ));

-- index
CREATE INDEX aidx_sa_paths_road_ids ON generated.sa_paths USING GIN (road_ids);
ANALYZE generated.sa_paths (road_ids);

SELECT * FROM generated.sa_paths;
```

##### > speed limit

```{sql, connection = connection, include = FALSE}

UPDATE  received.sa_ways SET speed_limit = NULL;

UPDATE  received.sa_ways
SET     speed_limit = substring(osm.maxspeed from '\d+')::INT
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

-- Things changed:removed last line where they prompted for speeds in mph.
```

##### > lanes

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways
SET     ft_lanes = NULL, tf_lanes = NULL, ft_cross_lanes = NULL, tf_cross_lanes = NULL;

UPDATE  received.sa_ways
SET     ft_lanes =
            CASE    WHEN osm."turn:lanes:forward" IS NOT NULL
                        THEN    array_length(
                                    regexp_split_to_array(
                                        osm."turn:lanes:forward",
                                        '\\|'
                                    ),
                                    1       -- only one dimension
                                )
                    WHEN osm."turn:lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'ft'
                        THEN    array_length(
                                    regexp_split_to_array(
                                        osm."turn:lanes",
                                        '\\|'
                                    ),
                                    1       -- only one dimension
                                )
                    WHEN osm."lanes:forward" IS NOT NULL
                        THEN    substring(osm."lanes:forward" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'ft'
                        THEN    substring(osm."lanes" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL
                        THEN    ceil(substring(osm."lanes" FROM '\\d+')::FLOAT / 2)
                    END,
        tf_lanes =
                    CASE    WHEN osm."turn:lanes:backward" IS NOT NULL
                                THEN    array_length(
                                            regexp_split_to_array(
                                                osm."turn:lanes:backward",
                                                '\\|'
                                            ),
                                            1       -- only one dimension
                                        )
                            WHEN osm."turn:lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'tf'
                                THEN    array_length(
                                            regexp_split_to_array(
                                                osm."turn:lanes",
                                                '\\|'
                                            ),
                                            1       -- only one dimension
                                        )
                            WHEN osm."lanes:backward" IS NOT NULL
                                THEN    substring(osm."lanes:backward" FROM '\\d+')::INT
                            WHEN osm."lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'tf'
                                THEN    substring(osm."lanes" FROM '\\d+')::INT
                            WHEN osm."lanes" IS NOT NULL
                                THEN    ceil(substring(osm."lanes" FROM '\\d+')::FLOAT / 2)
                            END,
        ft_cross_lanes =
            CASE    WHEN osm."turn:lanes:forward" IS NOT NULL
                        THEN    array_length(
                                    array_remove(
                                        regexp_split_to_array(
                                            osm."turn:lanes:forward",
                                            '\\|'
                                        ),
                                        'right'     -- don't consider right-only lanes for crossing stress
                                    ),
                                    1               -- only one dimension
                                )
                    WHEN osm."turn:lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'ft'
                        THEN    array_length(
                                    array_remove(
                                        regexp_split_to_array(
                                            osm."turn:lanes",
                                            '\\|'
                                        ),
                                        'right'     -- don't consider right-only lanes for crossing stress
                                    ),
                                    1               -- only one dimension
                                )
                    WHEN osm."lanes:forward" IS NOT NULL
                        THEN    substring(osm."lanes:forward" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'ft'
                        THEN    substring(osm."lanes" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL
                        THEN    ceil(substring(osm."lanes" FROM '\\d+')::FLOAT / 2)
                    END,
        tf_cross_lanes =
            CASE    WHEN osm."turn:lanes:backward" IS NOT NULL
                        THEN    array_length(
                                    array_remove(
                                        regexp_split_to_array(
                                            osm."turn:lanes:backward",
                                            '\\|'
                                        ),
                                        'right'     -- don't consider right-only lanes for crossing stress
                                    ),
                                    1               -- only one dimension
                                )
                    WHEN osm."turn:lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'tf'
                        THEN    array_length(
                                    array_remove(
                                        regexp_split_to_array(
                                            osm."turn:lanes",
                                            '\\|'
                                        ),
                                        'right'     -- don't consider right-only lanes for crossing stress
                                    ),
                                    1               -- only one dimension
                                )
                    WHEN osm."lanes:backward" IS NOT NULL
                        THEN    substring(osm."lanes:backward" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL AND received.sa_ways.one_way_car = 'tf'
                        THEN    substring(osm."lanes" FROM '\\d+')::INT
                    WHEN osm."lanes" IS NOT NULL
                        THEN    ceil(substring(osm."lanes" FROM '\\d+')::FLOAT / 2)
                    END,
        twltl_cross_lanes =
            CASE    WHEN osm."lanes:both_ways" IS NOT NULL THEN 1
                    WHEN osm."turn:lanes:both_ways" IS NOT NULL THEN 1
                    ELSE NULL
                    END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

-- Things changed: The original query used one_way column, but that one is not populated yet, so I changed it to one_way_car
```

##### > park

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_park = NULL, tf_park = NULL;

-- both
UPDATE  received.sa_ways
SET     ft_park = CASE  WHEN osm."parking:lane:both" = 'parallel' THEN 1
                        WHEN osm."parking:lane:both" = 'paralell' THEN 1
                        WHEN osm."parking:lane:both" = 'diagonal' THEN 1
                        WHEN osm."parking:lane:both" = 'perpendicular' THEN 1
                        WHEN osm."parking:lane:both" = 'no_parking' THEN 0
                        WHEN osm."parking:lane:both" = 'no_stopping' THEN 0
                        END,
        tf_park = CASE  WHEN osm."parking:lane:both" = 'parallel' THEN 1
                        WHEN osm."parking:lane:both" = 'paralell' THEN 1
                        WHEN osm."parking:lane:both" = 'diagonal' THEN 1
                        WHEN osm."parking:lane:both" = 'perpendicular' THEN 1
                        WHEN osm."parking:lane:both" = 'no_parking' THEN 0
                        WHEN osm."parking:lane:both" = 'no_stopping' THEN 0
                        END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

-- right
UPDATE  received.sa_ways
SET     ft_park = CASE  WHEN osm."parking:lane:right" = 'parallel' THEN 1
                        WHEN osm."parking:lane:right" = 'paralell' THEN 1
                        WHEN osm."parking:lane:right" = 'diagonal' THEN 1
                        WHEN osm."parking:lane:right" = 'perpendicular' THEN 1
                        WHEN osm."parking:lane:right" = 'no_parking' THEN 0
                        WHEN osm."parking:lane:right" = 'no_stopping' THEN 0
                        END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

-- left
UPDATE  received.sa_ways
SET     tf_park = CASE  WHEN osm."parking:lane:left" = 'parallel' THEN 1
                        WHEN osm."parking:lane:left" = 'paralell' THEN 1
                        WHEN osm."parking:lane:left" = 'diagonal' THEN 1
                        WHEN osm."parking:lane:left" = 'perpendicular' THEN 1
                        WHEN osm."parking:lane:left" = 'no_parking' THEN 0
                        WHEN osm."parking:lane:left" = 'no_stopping' THEN 0
                        END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

```

##### > bike infrastructure

```{sql, connection = connection, include = FALSE}

UPDATE  received.sa_ways SET ft_bike_infra = NULL, tf_bike_infra = NULL;

----------------------
-- ft direction
----------------------
UPDATE  received.sa_ways
SET     ft_bike_infra = CASE

            -- :both
            WHEN osm."cycleway:both" = 'shared_lane'
                THEN 'sharrow'
            WHEN osm."cycleway:both" = 'buffered_lane'
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane' AND osm."cycleway:both:buffer" IN ('yes','both','right','left')
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane'
                THEN 'lane'
            WHEN osm."cycleway:both" = 'track'
                THEN 'track'
            WHEN (osm."cycleway:right" = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'
            WHEN (osm."cycleway:left" = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'
            WHEN (osm.cycleway = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'

            -- one-way=ft
            WHEN one_way_car = 'ft'
                THEN CASE   WHEN osm."cycleway:left" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:left:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:left" = 'track'
                                THEN 'track'

                            -- stuff from two-way that also applies to one-way=ft
                            WHEN osm.cycleway = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:right" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm.cycleway = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:right:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:right" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'track'
                                THEN 'track'
                            WHEN osm."cycleway:right" = 'track'
                                THEN 'track'
                            END

            -- one-way=tf
            WHEN one_way_car = 'tf'
                THEN CASE   WHEN osm.cycleway = 'opposite_lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'opposite_lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'opposite_lane' AND osm."cycleway:right:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'opposite_lane'
                                THEN 'lane'
                            WHEN osm."cycleway:right" = 'opposite_lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'opposite_track'
                                THEN 'track'
                            WHEN (one_way_car = 'tf' AND osm."cycleway:left" = 'opposite_track')
                                THEN 'track'
                            WHEN (one_way_car = 'tf' AND osm."cycleway:right" = 'opposite_track')
                                THEN 'track'
                            END

            -- two-way
            WHEN one_way_car IS NULL
                THEN CASE   WHEN osm.cycleway = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:right" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm.cycleway = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:right:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:right" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'track'
                                THEN 'track'
                            WHEN osm."cycleway:right" = 'track'
                                THEN 'track'
                            END
            END,

        tf_bike_infra = CASE

            -- :both
            WHEN osm."cycleway:both" = 'shared_lane'
                THEN 'sharrow'
            WHEN osm."cycleway:both" = 'buffered_lane'
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane' AND osm."cycleway:both:buffer" IN ('yes','both','right','left')
                THEN 'buffered_lane'
            WHEN osm."cycleway:both" = 'lane'
                THEN 'lane'
            WHEN osm."cycleway:both" = 'track'
                THEN 'track'
            WHEN (osm."cycleway:right" = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'
            WHEN (osm."cycleway:left" = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'
            WHEN (osm.cycleway = 'track' AND osm."oneway:bicycle" = 'no')
                THEN 'track'

            -- one-way=tf
            WHEN one_way_car = 'tf'
                THEN CASE   WHEN osm."cycleway:right" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane' AND osm."cycleway:right:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:right" = 'track'
                                THEN 'track'

                            -- stuff from two-way that also applies to one-way=tf
                            WHEN osm.cycleway = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:left" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm.cycleway = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:left:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:left" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'track'
                                THEN 'track'
                            WHEN osm."cycleway:left" = 'track'
                                THEN 'track'
                            END

            -- one-way=ft
            WHEN one_way_car = 'ft'
                THEN CASE   WHEN osm.cycleway = 'opposite_lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'opposite_lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:right" = 'opposite_lane' AND osm."cycleway:right:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'opposite_lane'
                                THEN 'lane'
                            WHEN osm."cycleway:right" = 'opposite_lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'opposite_track'
                                THEN 'track'
                            WHEN (one_way_car = 'tf' AND osm."cycleway:left" = 'opposite_track')
                                THEN 'track'
                            WHEN (one_way_car = 'tf' AND osm."cycleway:right" = 'opposite_track')
                                THEN 'track'
                            END

            -- two-way
            WHEN one_way_car IS NULL
                THEN CASE   WHEN osm.cycleway = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm."cycleway:left" = 'shared_lane'
                                THEN 'sharrow'
                            WHEN osm.cycleway = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'buffered_lane'
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm."cycleway:left" = 'lane' AND osm."cycleway:left:buffer" IN ('yes','both','right','left')
                                THEN 'buffered_lane'
                            WHEN osm.cycleway = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway:left" = 'lane'
                                THEN 'lane'
                            WHEN osm."cycleway" = 'track'
                                THEN 'track'
                            WHEN osm."cycleway:left" = 'track'
                                THEN 'track'
                            END
            END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id;

-- update one_way based on bike infra
UPDATE  received.sa_ways
SET     one_way = NULL;
UPDATE  received.sa_ways
SET     one_way = one_way_car
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     one_way_car = 'ft'
AND     NOT (tf_bike_infra IS NOT NULL OR COALESCE(osm."oneway:bicycle",'yes') = 'no');
UPDATE  received.sa_ways
SET     one_way = one_way_car
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     one_way_car = 'tf'
AND     NOT (ft_bike_infra IS NOT NULL OR COALESCE(osm."oneway:bicycle",'yes') = 'no');

-- get facility widths
UPDATE  received.sa_ways
SET     ft_bike_infra_width = CASE

            -- feet
            WHEN osm."cycleway:right:width" LIKE '% ft'
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN one_way_car = 'ft' AND osm."cycleway:left:width" LIKE '% ft'
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN osm."cycleway:both:width" LIKE '% ft'
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN osm."cycleway:width" LIKE '% ft'
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084

            -- meters
            WHEN osm."cycleway:right:width" LIKE '% m'
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN one_way_car = 'ft' AND osm."cycleway:left:width" LIKE '% m'
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:both:width" LIKE '% m'
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:width" LIKE '% m'
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT

            -- no units (default=meters)
            WHEN osm."cycleway:right:width" IS NOT NULL
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN one_way_car = 'ft' AND osm."cycleway:left:width" IS NOT NULL
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:both:width" IS NOT NULL
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:width" IS NOT NULL
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     ft_bike_infra IS NOT NULL;

UPDATE  received.sa_ways
SET     tf_bike_infra_width = CASE

            -- feet
            WHEN osm."cycleway:left:width" LIKE '% ft'
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN one_way_car = 'tf' AND osm."cycleway:right:width" LIKE '% ft'
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN osm."cycleway:both:width" LIKE '% ft'
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084
            WHEN osm."cycleway:width" LIKE '% ft'
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT/3.28084

            -- meters
            WHEN osm."cycleway:left:width" LIKE '% m'
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN one_way_car = 'tf' AND osm."cycleway:right:width" LIKE '% m'
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:both:width" LIKE '% m'
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:width" LIKE '% m'
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT

            -- no units (default=meters)
            WHEN osm."cycleway:left:width" IS NOT NULL
                THEN substring("cycleway:left:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN one_way_car = 'tf' AND osm."cycleway:right:width" IS NOT NULL
                THEN substring("cycleway:right:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:both:width" IS NOT NULL
                THEN substring("cycleway:both:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            WHEN osm."cycleway:width" IS NOT NULL
                THEN substring("cycleway:width" from '\\d+\\.?\\d?\\d?')::FLOAT
            END
FROM    received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     tf_bike_infra IS NOT NULL;

```

##### > class adjustments

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways
SET     functional_class = 'tertiary'
WHERE   functional_class IN ('residential','unclassified')
AND     (
            ft_bike_infra IN ('track','buffered_lane','lane')
        OR  tf_bike_infra IN ('track','buffered_lane','lane')
        OR  ft_lanes > 1
        OR  tf_lanes > 1
        OR  speed_limit >= 50
        );

-- Things changed: speed limit from 30 mph to 50 kmh
```

#### - Populate intersection table

Which does modifications to the following columns on the intersection table.

##### > legs

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways_int
SET     legs = (
            SELECT  COUNT(road_id)
            FROM    received.sa_ways
            WHERE   received.sa_ways_int.int_id IN (intersection_from,intersection_to)
);

```

##### > signalized

```{sql, connection = connection, include = FALSE}
UPDATE received.sa_ways_int SET signalized = 'f';

-----------------------------------
-- traffic signals
-----------------------------------
UPDATE  received.sa_ways_int
SET     signalized = 't'
FROM    received.sa_full_point osm
WHERE   received.sa_ways_int.osm_id = osm.osm_id
AND     osm.highway = 'traffic_signals';

UPDATE  received.sa_ways_int
SET     signalized = 't'
FROM    received.sa_ways,
        received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     int_id = received.sa_ways.intersection_to
AND     osm."traffic_signals:direction" = 'forward';

UPDATE  received.sa_ways_int
SET     signalized = 't'
FROM    received.sa_ways,
        received.sa_full_line osm
WHERE   received.sa_ways.osm_id = osm.osm_id
AND     int_id = received.sa_ways.intersection_from
AND     osm."traffic_signals:direction" = 'backward';


-----------------------------------
-- HAWKs and other variants
-----------------------------------
UPDATE  received.sa_ways_int
SET     signalized = 't'
WHERE   legs > 2
AND     EXISTS (
            SELECT  1
            FROM    received.sa_full_point osm
            WHERE   osm.highway = 'crossing'
            AND     osm.crossing IN ('traffic_signals','pelican','toucan')
            AND     ST_DWithin(received.sa_ways_int.geom, osm.way, 25)
        );


-----------------------------------
-- Capture signals from other points
-- on the intersection
-----------------------------------
UPDATE  received.sa_ways_int
SET     signalized = 't'
WHERE   legs > 2
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways_int i
            WHERE   i.signalized
            AND     ST_DWithin(received.sa_ways_int.geom, i.geom, 25)
        );

```

##### > stops

```{sql, connection = connection, include = FALSE}
UPDATE received.sa_ways_int SET stops = 'f';

UPDATE  received.sa_ways_int
SET     stops = 't'
FROM    received.sa_full_point osm
WHERE   received.sa_ways_int.osm_id = osm.osm_id
AND     osm.highway = 'stop'
AND     osm.stop = 'all';

UPDATE  received.sa_ways_int
SET     stops = 't'
WHERE   legs > 2
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways_int i
            WHERE   i.stops
            AND     ST_DWithin(received.sa_ways_int.geom, i.geom, 25)
        );

```

##### > rrfb

```{sql, connection = connection, include = FALSE}
UPDATE received.sa_ways_int SET rrfb = FALSE;

UPDATE  received.sa_ways_int
SET     rrfb = TRUE
WHERE   legs > 2
AND     EXISTS (
            SELECT  1
            FROM    received.sa_full_point osm
            WHERE   osm.highway = 'crossing'
            AND     osm.flashing_lights = 'yes'
            AND     ST_DWithin(received.sa_ways_int.geom, osm.way, 25)
        );
```

##### > island

```{sql, connection = connection, include = FALSE}
UPDATE received.sa_ways_int SET island = FALSE;

UPDATE  received.sa_ways_int
SET     island = TRUE
WHERE   legs > 2
AND     EXISTS (
            SELECT  1
            FROM    received.sa_full_point osm
            WHERE   osm.highway = 'crossing'
            AND     osm.crossing = 'island'
            AND     ST_DWithin(received.sa_ways_int.geom, osm.way, 25)
        );
```

An example of how the tables look like after this step:

```{sql, connection = connection, tab.cap = "Ways table"}
SELECT * FROM received.sa_ways LIMIT 10;
```

```{sql, connection = connection, tab.cap = "Intersection table table"}
SELECT * FROM received.sa_ways_int LIMIT 10;
```

The code for this step is not included as it is basically the same as the PfB code, and is actually quite long. However, it can be examined through the *Rmd* file for this R Notebook.

One additional value that I was considering on adding is slope, however I have not gone through with the complete implementation of the variable yet. This would also affect step 6. 

### 6. Calculate stress

The same as step 5, this step considers mainly SQL queries already performed by PfB. It will mainly alter the columns meant to host the stress rank for segments and intersections. It considers different cases to do the classification. The scripts that can be further examined on the *Rmd* file are:

##### > motorway trunk

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_seg_stress = NULL, tf_seg_stress = NULL
WHERE   functional_class IN ('motorway','motorway_link','trunk','trunk_link');

UPDATE  received.sa_ways SET ft_seg_stress = 3, tf_seg_stress = 3
WHERE   functional_class IN ('motorway','motorway_link','trunk','trunk_link');
```

##### > higher order

```{r higher order, include = FALSE, warning = FALSE}
stress_higher_order_ways <- function(
  class, 
  default_speed, 
  default_lanes, 
  default_parking,
  default_parking_width,
  default_facility_width
  )
{
  sqldf(
    paste0(
      "
UPDATE  received.sa_ways SET ft_seg_stress = NULL, tf_seg_stress = NULL
WHERE   functional_class IN ('", class, "','", class, "'||'_link');

-- ft direction
UPDATE  received.sa_ways
SET     ft_seg_stress =
            CASE
            WHEN ft_bike_infra = 'track' THEN 1
            WHEN ft_bike_infra = 'buffered_lane'
                THEN    CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") > 60 THEN 3
                        WHEN COALESCE(speed_limit,", default_speed, ") = 60
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE    CASE
                                            WHEN COALESCE(ft_park,", default_parking, ") = 1 THEN 2
                                            ELSE 1
                                            END
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") = 50
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") > 1
                                        THEN    CASE
                                                WHEN COALESCE(ft_park,", default_parking, ") = 1 THEN 2
                                                ELSE 1
                                                END
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") < 50 THEN 1
                        ELSE 3
                        END
            WHEN ft_bike_infra = 'lane' AND COALESCE(ft_park,", default_parking, ") = 0  -- bike lane with no parking
                THEN    CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") > 50 THEN 3
                        WHEN COALESCE(speed_limit,", default_speed, ") = 50
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") = 40
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") > 2 THEN 3
                                    ELSE 1
                                    END
                        ELSE 3
                        END
            WHEN ft_bike_infra = 'lane' AND COALESCE(ft_park,", default_parking, ") = 1
                THEN    CASE
                        WHEN COALESCE(ft_bike_infra_width,", default_facility_width, ") + ", default_parking_width, " >= 5   -- treat as buffered lane
                            THEN    CASE
                                    WHEN COALESCE(speed_limit,", default_speed, ") > 60 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 60 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 50
                                        THEN    CASE
                                                WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 2
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") < 50 THEN 1
                                    ELSE 3
                                    END
                        WHEN COALESCE(ft_bike_infra_width,", default_facility_width, ") + ", default_parking_width, " >= 4   -- treat as bike lane with no parking
                            THEN    CASE
                                    WHEN COALESCE(speed_limit,", default_speed, ") > 50 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 50
                                        THEN    CASE
                                                WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 3
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 40
                                        THEN    CASE
                                                WHEN COALESCE(ft_lanes,", default_lanes, ") > 1 THEN 3
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                                        THEN    CASE
                                                WHEN COALESCE(ft_lanes,", default_lanes, ") > 2 THEN 3
                                                ELSE 1
                                                END
                                    ELSE 3
                                    END
                        ELSE 3
                        END
            ELSE                -- shared lane
                        CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                            THEN    CASE
                                    WHEN COALESCE(ft_lanes,", default_lanes, ") = 1 THEN 1
                                    ELSE 3
                                    END
                        ELSE 3
                        END
            END,
        tf_seg_stress =
            CASE
            WHEN tf_bike_infra = 'track' THEN 1
            WHEN tf_bike_infra = 'buffered_lane'
                THEN    CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") > 60 THEN 3
                        WHEN COALESCE(speed_limit,", default_speed, ") = 60
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE    CASE
                                            WHEN COALESCE(tf_park,", default_parking, ") = 1 THEN 2
                                            ELSE 1
                                            END
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") = 50
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") > 1
                                        THEN    CASE
                                                WHEN COALESCE(tf_park,", default_parking, ") = 1 THEN 2
                                                ELSE 1
                                                END
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") < 50 THEN 1
                        ELSE 3
                        END
            WHEN tf_bike_infra = 'lane' AND COALESCE(tf_park,", default_parking, ") = 0  -- bike lane with no parking
                THEN    CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") > 50 THEN 3
                        WHEN COALESCE(speed_limit,", default_speed, ") = 50
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") = 40
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 3
                                    ELSE 1
                                    END
                        WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") > 2 THEN 3
                                    ELSE 1
                                    END
                        ELSE 3
                        END
            WHEN tf_bike_infra = 'lane' AND COALESCE(tf_park,", default_parking, ") = 1
                THEN    CASE
                        WHEN COALESCE(tf_bike_infra_width,", default_facility_width, ") + ", default_parking_width, " >= 5   -- treat as buffered lane
                            THEN    CASE
                                    WHEN COALESCE(speed_limit,", default_speed, ") > 60 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 60 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 50
                                        THEN    CASE
                                                WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 2
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") < 50 THEN 1
                                    ELSE 3
                                    END
                        WHEN COALESCE(tf_bike_infra_width,", default_facility_width, ") + ", default_parking_width, " >= 4   -- treat as bike lane with no parking
                            THEN    CASE
                                    WHEN COALESCE(speed_limit,", default_speed, ") > 50 THEN 3
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 50
                                        THEN    CASE
                                                WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 3
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") = 40
                                        THEN    CASE
                                                WHEN COALESCE(tf_lanes,", default_lanes, ") > 1 THEN 3
                                                ELSE 1
                                                END
                                    WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                                        THEN    CASE
                                                WHEN COALESCE(tf_lanes,", default_lanes, ") > 2 THEN 3
                                                ELSE 1
                                                END
                                    ELSE 3
                                    END
                        ELSE 3
                        END
            ELSE                -- shared lane
                        CASE
                        WHEN COALESCE(speed_limit,", default_speed, ") <= 30
                            THEN    CASE
                                    WHEN COALESCE(tf_lanes,", default_lanes, ") = 1 THEN 1
                                    ELSE 3
                                    END
                        ELSE 3
                        END
            END
WHERE   functional_class IN ('", class, "','", class, "'||'_link');
      "
    ),
    connection = connection
  )
}

stress_higher_order_ways(
  class = "primary", 
  default_speed = 70, 
  default_lanes = 2, 
  default_parking = 1,
  default_parking_width = 2.5,
  default_facility_width = 1.5
)

stress_higher_order_ways(
  class = "secondary", 
  default_speed = 70, 
  default_lanes = 2, 
  default_parking = 1,
  default_parking_width = 2.5,
  default_facility_width = 1.5
)

stress_higher_order_ways(
  class = "tertiary", 
  default_speed = 50, 
  default_lanes = 1, 
  default_parking = 1,
  default_parking_width = 2.5,
  default_facility_width = 1.5
)

# Things changed: speeds - 40mph=70kmh 35mph=60kmh 30mph=50kmh 25mph=40kmh 20mph=30kmh, width - 15ft=5m 13ft=4m 8ft=2.5m 5ft=1.5m 27ft=8m 19ft=6m
```

##### > lower order

```{r lower order, include = FALSE, warning = FALSE}

stress_lower_order_ways <- function(
  class, 
  default_speed, 
  default_lanes, 
  default_parking,
  default_roadway_width
  )
{
  sqldf(
    paste0(
      "
UPDATE  received.sa_ways SET ft_seg_stress=NULL, tf_seg_stress=NULL
  WHERE   functional_class = '", class, "';
  
  UPDATE  received.sa_ways
  SET     ft_seg_stress =
              CASE
              WHEN COALESCE(speed_limit,", default_speed, ") = 40
                  THEN    CASE
                          WHEN COALESCE(ft_park,", default_parking, ") + COALESCE(tf_park,", default_parking, ") = 2    -- parking on both sides
                              THEN    CASE
                                      WHEN COALESCE(width,", default_roadway_width, ") >= 8
                                          THEN 1
                                      ELSE 2
                                      END
                          ELSE    CASE                                                                        -- parking on one side
                                  WHEN COALESCE(width,", default_roadway_width, ") >= 6
                                      THEN 1
                                  ELSE 2
                                  END
                          END
              WHEN COALESCE(speed_limit,", default_speed, ") <= 30 THEN 1
              ELSE 3
              END,
          tf_seg_stress =
              CASE
              WHEN COALESCE(speed_limit,", default_speed, ") = 40
                  THEN    CASE
                          WHEN COALESCE(ft_park,", default_parking, ") + COALESCE(tf_park,", default_parking, ") = 2    -- parking on both sides
                              THEN    CASE
                                      WHEN COALESCE(width,", default_roadway_width, ") >= 8
                                          THEN 1
                                      ELSE 2
                                      END
                          ELSE    CASE                                                                        -- parking on one side
                                  WHEN COALESCE(width,", default_roadway_width, ") >= 6
                                      THEN 1
                                  ELSE 2
                                  END
                          END
              WHEN COALESCE(speed_limit,", default_speed, ") <= 30 THEN 1
              ELSE 3
              END
  WHERE   functional_class = '", class, "';
  
      "
    ),
    connection = connection
  )
}



stress_lower_order_ways(
  class = "residential", 
  default_speed = 40, 
  default_lanes = 1, 
  default_parking = 1,
  default_roadway_width = 8
)

stress_lower_order_ways(
  class = "unclassified", 
  default_speed = 40, 
  default_lanes = 1, 
  default_parking = 1,
  default_roadway_width = 8
)

# Remark: why do they use default_lanes if the function does not use it?
```

##### > living street

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_seg_stress = NULL, tf_seg_stress = NULL
WHERE   functional_class = 'living_street';

UPDATE  received.sa_ways
SET     ft_seg_stress = 3,
        tf_seg_stress = 3
FROM    received.sa_full_line osm
WHERE   functional_class = 'living_street'
AND     received.sa_ways.osm_id = osm.osm_id
AND     osm.bicycle = 'no';

UPDATE  received.sa_ways
SET     ft_seg_stress = COALESCE(ft_seg_stress,1),
        tf_seg_stress = COALESCE(tf_seg_stress,1)
WHERE   functional_class = 'living_street';
```

##### > track

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_seg_stress = NULL, tf_seg_stress = NULL
WHERE   functional_class = 'track';

UPDATE  received.sa_ways
SET     ft_seg_stress = 1,
        tf_seg_stress = 1
WHERE   functional_class = 'track';
```

##### > path

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_seg_stress = NULL, tf_seg_stress = NULL
WHERE   functional_class = 'path';

UPDATE  received.sa_ways
SET     ft_seg_stress = 1,
        tf_seg_stress = 1
WHERE   functional_class = 'path';
```

##### > one way reset

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways
SET     ft_seg_stress = NULL
WHERE   one_way = 'tf';

UPDATE  received.sa_ways
SET     tf_seg_stress = NULL
WHERE   one_way = 'ft';

-- reset opposite stress for one-way
```

##### > motorway trunk intersection

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class IN ('motorway','trunk');

-- assume low stress, since these juncions would always be controlled or free flowing
```

##### > primary intersection

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class = 'primary';

-- assume low stress, since these juncions would always be controlled or free flowing
```

##### > secondary intersection 

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class = 'secondary';

-- assume low stress, since these juncions would always be controlled or free flowing
```

##### > tertiary intersection 

```{r tertiary intersection, include = FALSE, warning = FALSE}
stress_tertiary_int <- function(
  primary_speed, 
  secondary_speed, 
  primary_lanes, 
  secondary_lanes
  )
{
  sqldf(
    paste0(
      "
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class = 'tertiary';

-- ft
UPDATE  received.sa_ways
SET     ft_int_stress = 3
FROM    received.sa_ways_int i
WHERE   functional_class = 'tertiary'
AND     received.sa_ways.intersection_to = i.int_id
AND     NOT i.signalized
AND     NOT i.stops
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   i.int_id IN (w.intersection_to,w.intersection_from)
            AND     COALESCE(received.sa_ways.name,'a') != COALESCE(w.name,'b')
            AND     CASE
                    WHEN w.functional_class IN ('motorway','trunk') THEN TRUE

                    -- two way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END
                    END
);


-- tf
UPDATE  received.sa_ways
SET     tf_int_stress = 3
FROM    received.sa_ways_int i
WHERE   functional_class = 'tertiary'
AND     received.sa_ways.intersection_from = i.int_id
AND     NOT i.signalized
AND     NOT i.stops
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   i.int_id IN (w.intersection_to,w.intersection_from)
            AND     COALESCE(received.sa_ways.name,'a') != COALESCE(w.name,'b')
            AND     CASE
                    WHEN w.functional_class IN ('motorway','trunk') THEN TRUE

                    -- two way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END
                    END
);

      "
    ),
  connection = connection
)
}

stress_tertiary_int(
  primary_speed = 70,
  secondary_speed = 70,
  primary_lanes = 2,
  secondary_lanes = 2
)

```

##### > lower intersection 

```{r lower intersection, include = FALSE, warning = FALSE}
stress_lower_int <- function(
  primary_speed,
  secondary_speed,
  tertiary_speed,
  primary_lanes,
  secondary_lanes,
  tertiary_lanes
)
{
  sqldf(
    paste0(
      "
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class IN ('residential','unclassified','living_street','track','path');

-- ft
UPDATE  received.sa_ways
SET     ft_int_stress = 3
FROM    received.sa_ways_int i
WHERE   functional_class IN ('residential','unclassified','living_street','track','path')
AND     received.sa_ways.intersection_to = i.int_id
AND     NOT i.signalized
AND     NOT i.stops
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   i.int_id IN (w.intersection_to,w.intersection_from)
            AND     COALESCE(received.sa_ways.name,'a') != COALESCE(w.name,'b')
            AND     CASE
                    WHEN w.functional_class IN ('motorway','trunk') THEN TRUE

                    -- two way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way tertiary
                    WHEN w.functional_class = 'tertiary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way tertiary
                    WHEN w.functional_class = 'tertiary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END
                    END
);


-- tf
UPDATE  received.sa_ways
SET     tf_int_stress = 3
FROM    received.sa_ways_int i
WHERE   functional_class IN ('residential','unclassified','living_street','track','path')
AND     received.sa_ways.intersection_from = i.int_id
AND     NOT i.signalized
AND     NOT i.stops
AND     EXISTS (
            SELECT  1
            FROM    received.sa_ways w
            WHERE   i.int_id IN (w.intersection_to,w.intersection_from)
            AND     COALESCE(received.sa_ways.name,'a') != COALESCE(w.name,'b')
            AND     CASE
                    WHEN w.functional_class IN ('motorway','trunk') THEN TRUE

                    -- two way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", primary_lanes, ") + COALESCE(w.tf_lanes,", primary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way primary
                    WHEN w.functional_class = 'primary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 60 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", primary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", primary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", secondary_lanes, ") + COALESCE(w.tf_lanes,", secondary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way secondary
                    WHEN w.functional_class = 'secondary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", secondary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", secondary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- two way tertiary
                    WHEN w.functional_class = 'tertiary' AND w.one_way IS NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") > 4 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 70 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 60
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") = 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50 THEN TRUE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") = 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,", tertiary_lanes, ") + COALESCE(w.tf_lanes,", tertiary_lanes, ") < 4
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN    CASE
                                                                    WHEN i.island THEN FALSE
                                                                    ELSE TRUE
                                                                    END
                                                        ELSE FALSE
                                                        END
                                            END
                                END

                    -- one way tertiary
                    WHEN w.functional_class = 'tertiary' AND w.one_way IS NOT NULL
                        THEN    CASE
                                WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") > 2 THEN TRUE

                                -- with rrfb
                                WHEN i.rrfb
                                    THEN    CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 70 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 60
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END

                                -- without rrfb
                                ELSE        CASE
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") = 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50 THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            WHEN COALESCE(w.ft_lanes,w.tf_lanes,", tertiary_lanes, ") < 2
                                                THEN    CASE
                                                        WHEN COALESCE(w.speed_limit,", tertiary_speed, ") > 50
                                                            THEN TRUE
                                                        ELSE FALSE
                                                        END
                                            END
                                END
                    END
);

      "
    ),
    connection = connection
  )
}

stress_lower_int(
  primary_speed = 70,
  secondary_speed = 70,
  tertiary_speed = 50,
  primary_lanes = 2,
  secondary_lanes = 2,
  tertiary_lanes = 1
)

```

##### > link intersection

```{sql, connection = connection, include = FALSE}
UPDATE  received.sa_ways SET ft_int_stress = 1, tf_int_stress = 1
WHERE   functional_class LIKE '%_link';
```

An example of how the tables look like after this step:

```{sql, connection = connection, tab.cap = "Ways table"}
SELECT osm_id, name, ft_seg_stress, tf_seg_stress, ft_int_stress, tf_int_stress FROM received.sa_ways LIMIT 10;
```

### 7. Build network

On this step the network is built by creating two tables: vertices and links. As the last 2 steps, the code won't be include but can be analyzed on the *Rmd* file. 

```{sql, connection = connection, include = FALSE}
DROP TABLE IF EXISTS received.sa_ways_net_vert;
DROP TABLE IF EXISTS received.sa_ways_net_link;

-- create new tables
CREATE TABLE received.sa_ways_net_vert (
    vert_id SERIAL PRIMARY KEY,
    road_id INTEGER,
    vert_cost INTEGER,
    geom geometry(point,?sa_crs)
);

CREATE TABLE received.sa_ways_net_link (
    link_id SERIAL PRIMARY KEY,
    int_id INTEGER,
    turn_angle INTEGER,
    int_crossing BOOLEAN,
    int_stress INTEGER,
    source_vert INTEGER,
    source_road_id INTEGER,
    source_road_dir VARCHAR(2),
    source_road_azi INTEGER,
    source_road_length INTEGER,
    source_stress INTEGER,
    target_vert INTEGER,
    target_road_id INTEGER,
    target_road_dir VARCHAR(2),
    target_road_azi INTEGER,
    target_road_length INTEGER,
    target_stress INTEGER,
    link_cost INTEGER,
    link_stress INTEGER,
    geom geometry(linestring,?sa_crs)
);

-- create vertices
INSERT INTO received.sa_ways_net_vert (road_id, geom)
SELECT  ways.road_id,
        ST_LineInterpolatePoint(ways.geom,0.5)
FROM    received.sa_ways ways;

-- index
CREATE INDEX sidx_sa_ways_net_vert_geom ON received.sa_ways_net_vert USING gist (geom);
CREATE INDEX idx_sa_ways_net_vert_roadid ON received.sa_ways_net_vert (road_id);
ANALYZE received.sa_ways_net_vert;

---------------
-- add links --
---------------
-- two-way to two-way
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id IN (roads1.intersection_from, roads1.intersection_to)
AND     ints.int_id IN (roads2.intersection_from, roads2.intersection_to)
AND     roads1.one_way IS NULL
AND     roads2.one_way IS NULL
AND     roads1.road_id != roads2.road_id;

-- two-way to from-to
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id IN (roads1.intersection_from, roads1.intersection_to)
AND     ints.int_id = roads2.intersection_from
AND     roads1.one_way IS NULL
AND     roads2.one_way = 'ft'
AND     roads1.road_id != roads2.road_id;

-- two-way to to-from
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id IN (roads1.intersection_from, roads1.intersection_to)
AND     ints.int_id = roads2.intersection_to
AND     roads1.one_way IS NULL
AND     roads2.one_way = 'tf'
AND     roads1.road_id != roads2.road_id;

-- from-to to two-way
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_to
AND     ints.int_id IN (roads2.intersection_from, roads2.intersection_to)
AND     roads1.one_way = 'ft'
AND     roads2.one_way IS NULL
AND     roads1.road_id != roads2.road_id;

-- from-to to from-to
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_to
AND     ints.int_id = roads2.intersection_from
AND     roads1.one_way = 'ft'
AND     roads2.one_way = 'ft'
AND     roads1.road_id != roads2.road_id;

-- from-to to to-from
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_to
AND     ints.int_id = roads2.intersection_to
AND     roads1.one_way = 'ft'
AND     roads2.one_way = 'tf'
AND     roads1.road_id != roads2.road_id;

-- to-from to two-way
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_from
AND     ints.int_id IN (roads2.intersection_from, roads2.intersection_to)
AND     roads1.one_way = 'tf'
AND     roads2.one_way IS NULL
AND     roads1.road_id != roads2.road_id;

-- to-from to to-from
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_from
AND     ints.int_id = roads2.intersection_to
AND     roads1.one_way = 'tf'
AND     roads2.one_way = 'tf'
AND     roads1.road_id != roads2.road_id;

-- to-from to from-to
INSERT INTO received.sa_ways_net_link (int_id, source_vert, target_vert, geom)
SELECT  ints.int_id,
        vert1.vert_id,
        vert2.vert_id,
        ST_Makeline(vert1.geom,vert2.geom)
FROM    received.sa_ways_int ints,
        received.sa_ways_net_vert vert1,
        received.sa_ways roads1,
        received.sa_ways_net_vert vert2,
        received.sa_ways roads2
WHERE   vert1.road_id = roads1.road_id
AND     vert2.road_id = roads2.road_id
AND     ints.int_id = roads1.intersection_from
AND     ints.int_id = roads2.intersection_from
AND     roads1.one_way = 'tf'
AND     roads2.one_way = 'ft'
AND     roads1.road_id != roads2.road_id;

-- index
CREATE INDEX idx_sa_ways_net_vert_road_id ON received.sa_ways_net_vert (road_id);
CREATE INDEX idx_sa_ways_net_link_int_id ON received.sa_ways_net_link (int_id);
CREATE INDEX idx_sa_ways_net_link_src_trgt ON received.sa_ways_net_link (source_vert,target_vert);
CREATE INDEX idx_sa_ways_net_link_src_rdid ON received.sa_ways_net_link (source_road_id);
CREATE INDEX idx_sa_ways_net_link_tgt_rdid ON received.sa_ways_net_link (target_road_id);
ANALYZE received.sa_ways_net_link;

--set source and target roads
UPDATE  received.sa_ways_net_link
SET     source_road_id = s_vert.road_id,
        target_road_id = t_vert.road_id
FROM    received.sa_ways_net_vert s_vert,
        received.sa_ways_net_vert t_vert
WHERE   received.sa_ways_net_link.source_vert = s_vert.vert_id
AND     received.sa_ways_net_link.target_vert = t_vert.vert_id;

--source_road_dir
UPDATE  received.sa_ways_net_link
SET     source_road_dir = CASE  WHEN received.sa_ways_net_link.int_id = road.intersection_to
                                    THEN 'ft'
                                ELSE 'tf'
                                END
FROM    received.sa_ways road
WHERE   received.sa_ways_net_link.source_road_id = road.road_id;

--target_road_dir
UPDATE  received.sa_ways_net_link
SET     target_road_dir = CASE  WHEN received.sa_ways_net_link.int_id = road.intersection_to
                                    THEN 'ft'
                                ELSE 'tf'
                                END
FROM    received.sa_ways road
WHERE   received.sa_ways_net_link.target_road_id = road.road_id;

--set azimuths and turn angles
UPDATE  received.sa_ways_net_link
SET     source_road_azi = CASE  WHEN source_road_dir = 'tf'
                                THEN degrees(ST_Azimuth(ST_LineInterpolatePoint(roads1.geom,0.5),ST_StartPoint(roads1.geom)))
                                ELSE degrees(ST_Azimuth(ST_LineInterpolatePoint(roads1.geom,0.5),ST_EndPoint(roads1.geom)))
                                END,
        target_road_azi = CASE  WHEN target_road_dir = 'tf'
                                THEN degrees(ST_Azimuth(ST_StartPoint(roads2.geom),ST_LineInterpolatePoint(roads2.geom,0.5)))
                                ELSE degrees(ST_Azimuth(ST_EndPoint(roads2.geom),ST_LineInterpolatePoint(roads2.geom,0.5)))
                                END
FROM    received.sa_ways roads1,
        received.sa_ways roads2
WHERE   source_road_id = roads1.road_id
AND     target_road_id = roads2.road_id;

UPDATE received.sa_ways_net_link
SET     turn_angle = (target_road_azi - source_road_azi + 360) % 360;

-------------------
-- set turn info --
-------------------
-- assume crossing is true unless proven otherwise
UPDATE received.sa_ways_net_link SET int_crossing = TRUE;

-- set right turns
UPDATE  received.sa_ways_net_link
SET     int_crossing = FALSE
WHERE   link_id = (
            SELECT      r.link_id
            FROM        received.sa_ways_net_link r
            WHERE       received.sa_ways_net_link.source_road_id = r.source_road_id
            AND         received.sa_ways_net_link.int_id = r.int_id
            ORDER BY    (sin(radians(r.turn_angle))>0)::INT DESC,
                        CASE    WHEN sin(radians(r.turn_angle))>0
                                THEN cos(radians(r.turn_angle))
                                ELSE -cos(radians(r.turn_angle))
                                END ASC
            LIMIT       1
);

--set lengths
UPDATE  received.sa_ways_net_link
SET     source_road_length = ST_Length(roads1.geom),
        target_road_length = ST_Length(roads2.geom)
FROM    received.sa_ways roads1,
        received.sa_ways roads2
WHERE   source_road_id = roads1.road_id
AND     target_road_id = roads2.road_id;

---------------------
-- set link stress --
---------------------
--source_stress
UPDATE  received.sa_ways_net_link
SET     source_stress = CASE WHEN received.sa_ways_net_link.int_id = road.intersection_to THEN road.ft_seg_stress
                        ELSE road.tf_seg_stress
                        END
FROM    received.sa_ways road
WHERE   received.sa_ways_net_link.source_road_id = road.road_id;

--int_stress
UPDATE  received.sa_ways_net_link
SET     int_stress = roads.ft_int_stress
FROM    received.sa_ways roads
WHERE   received.sa_ways_net_link.source_road_id = roads.road_id
AND     source_road_dir = 'ft';

UPDATE  received.sa_ways_net_link
SET     int_stress = roads.tf_int_stress
FROM    received.sa_ways roads
WHERE   received.sa_ways_net_link.source_road_id = roads.road_id
AND     source_road_dir = 'tf';

UPDATE  received.sa_ways_net_link
SET     int_stress = 1
WHERE   NOT int_crossing;;

--target_stress
UPDATE  received.sa_ways_net_link
SET     target_stress = CASE    WHEN received.sa_ways_net_link.int_id = road.intersection_to
                                    THEN road.tf_seg_stress
                                ELSE road.ft_seg_stress
                                END
FROM    received.sa_ways road
WHERE   received.sa_ways_net_link.target_road_id = road.road_id;

--link_stress
UPDATE  received.sa_ways_net_link
SET     link_stress = GREATEST(source_stress,int_stress,target_stress);

--------------
-- set cost --
--------------
UPDATE  received.sa_ways_net_link
SET     link_cost = ROUND((source_road_length + target_road_length) / 2);

-- Remark: what is vert_cost created as a column on the vertices if it is not going to be used?

SELECT * FROM received.sa_ways LIMIT 0;
```

### 8. Generate population grid

So, this is one of the main differences regarding the PfB approach and mine. Instead of using US census blocks I used a population grid of 1 km^2^ for the entire European territory. Since its area is quite big, I created a subdivision code to split the data, considering partial populations for each new cell depending on the mother cell. To do this I followed two steps:

#### - Download data from [EUROSTAT](https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/population-distribution-demography/geostat) and load into DB

```{r, warning = FALSE}
## Download data and load to PostgreSQL
if (!dbExistsTable(connection, c("received","geostat"))){
  
  # CREATE A NEW TEMPORAL DIRECTORY TO DOWNLOAD THE INFO
  cd <- getwd()
  ifelse(
    !file.exists(file.path(cd,'temp')),
    dir.create(file.path(cd,'temp')), 
    "Directory already exists"
  )
  
  # ESTABLISH THE NAME OF THE FILE WHERE THE GEOSTAT DATA WILL BE DOWNLOADED AND UNZIPPED
  geostat_file <- file.path(cd,'temp','geostat.zip')
  geostat_exdir <- file.path(cd,"temp","geostat")
  
  if (!file.exists(geostat_exdir)){
    # DEFINE THE URL FROM WHERE THE DATA COMES
  
    geostat_url <- 
      "https://ec.europa.eu/eurostat/cache/GISCO/geodatafiles/GEOSTAT-grid-POP-1K-2011-V2-0-1.zip"
    
    # DOWNLOAD THE FILE, UNZIP IT AND DELETE .ZIP
    
    library(utils)
    download.file(url = geostat_url, destfile = geostat_file)
    unzip(geostat_file, exdir = geostat_exdir)
    file.remove(geostat_file)
  }
  
  # CALL DATA INTO R AND REPROJECT
  library(sf)
  
  table_path <- file.path(
    geostat_exdir,
    "Version 2_0_1/GEOSTAT_grid_POP_1K_2011_V2_0_1.csv"
  )
  
  grid_path <- file.path(
    geostat_exdir,
    "Version 2_0_1/GEOSTATReferenceGrid/Grid_ETRS89_LAEA_1K-ref_GEOSTAT_POP_2011_V2_0_1.shp"
  )
  
  pop_table <- st_read(table_path)
  names(pop_table) <- pop_table %>% names() %>% tolower()
  
  pop_grid <- st_read(grid_path)
  pop_grid_t <- pop_grid %>% st_transform(crs = sa_crs)
  names(pop_grid_t) <- pop_grid_t %>% names() %>% tolower()
  
  # LOAD TO POSTGRESQL
  library(sqldf)
  sqldf(
    "
  DROP TABLE IF EXISTS received.pop_grid;
  DROP TABLE IF EXISTS received.pop_table;
    ",
  connection = connection
  )
  
  dbWriteTable(
    conn = connection,
    name = c("received","pop_grid"),
    value = pop_grid_t
  )
  
  dbWriteTable(
    conn = connection,
    name = c("received","pop_table"),
    value = pop_table
  )
  
  #### Join tables on data base and extract study area
  
  sqldf(
    "
-- Create join between .csv and .shp

DROP TABLE IF EXISTS received.geostat;
DROP INDEX IF EXISTS received.geostat_geom_idx;

CREATE TABLE received.geostat AS
 SELECT grid.grd_id, grid.geometry, tab.tot_p, tab.cntr_code, tab.year, tab.tot_p_con_dt
    FROM received.pop_grid grid, received.pop_table tab
    WHERE grid.grd_id = tab.grd_id;

CREATE INDEX geostat_geom_idx
  ON received.geostat
  USING gist
  (geometry);
  
DROP TABLE IF EXISTS received.pop_grid;
DROP TABLE IF EXISTS received.pop_table;
    ",
    connection = connection
  )
} else {
  "GEOSTAT data already loaded to database."
}
```

#### - Generate subdivision with a grid, adding partial population and unique ID

```{r, warning = FALSE}
sqldf::sqldf(
  "
DROP TABLE IF EXISTS received.sa_geostat;
DROP INDEX IF EXISTS received.sa_geostat_geom_idx;

-- Extract the grids concerning only the study area

CREATE TABLE received.sa_geostat AS
	SELECT 	DISTINCT geo.grd_id, 
			CAST(geo.tot_p AS INTEGER), 
			geo.cntr_code, 
			geo.geometry
	FROM received.geostat geo, received.sa_ways w
 	WHERE ST_Intersects(geo.geometry, w.geom);

CREATE INDEX sa_geostat_geom_idx
  ON received.sa_geostat
  USING gist
  (geometry);  
  ",
  connection = connection 
)

## Establish a function to create grid with different number of subdivisions, defaults to 9

grid <- function(s = 9){
  ## Call it as an sf object and then transform it to CRS:3035 to create grid
  library(sf)
  library(dplyr, quietly = TRUE)
  
  sa_pop_1km2 <- st_read(
    dsn = connection,
    layer = c("received", "sa_geostat")
  ) %>% 
    st_transform(crs = 3035)
  
  ## Determine number of horizontal and vertical cells
  h <- as.integer(as.numeric(diff(st_bbox(sa_pop_1km2)[c(1, 3)]))/1000)
  v <- as.integer(as.numeric(diff(st_bbox(sa_pop_1km2)[c(2, 4)]))/1000)
  
  ## Make grid
  grid <- sa_pop_1km2 %>% 
    st_make_grid(n=c(h*sqrt(s),v*sqrt(s)), what = "polygons") %>%
    st_sf() %>% 
    mutate(id = 1:n()) %>% 
    st_intersection(sa_pop_1km2)
  
  ## Filter grid by area of intersection because there are small polygons created.
  
  grid$area <- grid %>% st_geometry() %>% st_area() %>% as.numeric()
  
  grid <- grid %>% filter(area > 1)
  
  grid$area <- NULL
  
  grid <- within(grid, cell_id <- paste(grd_id,"C",id, sep = ""))
  
  grid$id <- NULL
  
  grid$partial_p <- grid$tot_p/s
  
  grid %>% st_transform(crs = sa_crs)
}

sa_grid <- grid(s = subdivisions) # Always consider a squared number to make an even division

sqldf::sqldf(
  "DROP TABLE IF EXISTS generated.sa_pop_grid",
  connection = connection
)

## Load data into data base
RPostgreSQL::dbWriteTable(
  conn = connection,
  name = c("generated","sa_pop_grid"),
  value = sa_grid
)
```

```{r, fig.width = 8, fig.height= 8,  echo = TRUE, warning = FALSE}
library(tmap)
tmap_mode("view")
qtm(
  shp = sa_grid, 
  fill = NULL, 
  borders = "red", 
  basemaps = "OpenStreetMap"
)
```

Plotting the grid on this step can allow the analyst decide on a better number of subdivisions, depending on the study area. I hope to automatize this on a later effort. 

#### - Prepare the population grid table

This step is only generating new columns on my new Population Grid table. It follows the same logic as the PfB and therefore won't be included on this document explicitly. 

```{sql, connection = connection, output.var = "output", include = FALSE}
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS road_ids;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pop_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pop_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pop_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS emp_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS emp_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS emp_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS schools_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS schools_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS schools_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS universities_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS universities_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS universities_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS colleges_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS colleges_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS colleges_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS doctors_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS doctors_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS doctors_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS dentists_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS dentists_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS dentists_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS hospitals_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS hospitals_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS hospitals_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pharmacies_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pharmacies_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS pharmacies_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS retail_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS retail_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS retail_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS supermarkets_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS supermarkets_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS supermarkets_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS social_services_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS social_services_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS social_services_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS parks_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS parks_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS parks_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS trails_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS trails_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS trails_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS community_centers_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS community_centers_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS community_centers_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS transit_low_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS transit_high_stress;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS transit_score;
ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS overall_score;

ALTER TABLE generated.sa_pop_grid ADD COLUMN road_ids INTEGER[];
ALTER TABLE generated.sa_pop_grid ADD COLUMN pop_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN pop_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN pop_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN emp_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN emp_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN emp_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN schools_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN schools_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN schools_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN universities_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN universities_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN universities_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN colleges_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN colleges_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN colleges_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN doctors_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN doctors_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN doctors_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN dentists_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN dentists_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN dentists_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN hospitals_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN hospitals_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN hospitals_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN pharmacies_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN pharmacies_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN pharmacies_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN retail_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN retail_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN retail_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN supermarkets_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN supermarkets_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN supermarkets_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN social_services_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN social_services_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN social_services_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN parks_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN parks_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN parks_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN trails_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN trails_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN trails_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN community_centers_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN community_centers_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN community_centers_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN transit_low_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN transit_high_stress INT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN transit_score FLOAT;
ALTER TABLE generated.sa_pop_grid ADD COLUMN overall_score FLOAT;

SELECT * FROM generated.sa_pop_grid;
```

```{r, include = FALSE, warning = FALSE}
sqldf(
  "
-- indexes
CREATE INDEX IF NOT EXISTS idx_sa_pop_grid_cell_id ON generated.sa_pop_grid (cell_id);
CREATE INDEX IF NOT EXISTS idx_sa_pop_grid_geom ON generated.sa_pop_grid USING GIST (geometry);
ANALYZE generated.sa_pop_grid;
  ",
  connection = connection
)
```

```{sql add_road_ids, connection = connection, include = FALSE, output.var = "output"}

ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS tmp_geom_buffer;
ALTER TABLE generated.sa_pop_grid ADD COLUMN tmp_geom_buffer geometry(multipolygon, ?sa_crs);

UPDATE  generated.sa_pop_grid
SET     tmp_geom_buffer = ST_Multi(ST_Buffer(geometry,5));
CREATE INDEX tsidx_sa_pop_grid_cellidbuffgeoms ON generated.sa_pop_grid USING GIST (tmp_geom_buffer);
ANALYZE generated.sa_pop_grid (tmp_geom_buffer);

UPDATE  generated.sa_pop_grid
SET     road_ids = array((
            SELECT  ways.road_id
            FROM    received.sa_ways ways
            WHERE   ST_Intersects(generated.sa_pop_grid.tmp_geom_buffer,ways.geom)
            AND     (
                        ST_Contains(generated.sa_pop_grid.tmp_geom_buffer,ways.geom)
                    OR  ST_Length(
                            ST_Intersection(generated.sa_pop_grid.tmp_geom_buffer,ways.geom)
                        ) > 10
                    )
        ));

ALTER TABLE generated.sa_pop_grid DROP COLUMN IF EXISTS tmp_geom_buffer;

SELECT * FROM generated.sa_pop_grid;
```

```{r, include = FALSE, warning = FALSE}
sqldf(
  "
-- index
CREATE INDEX aidx_sa_pop_grid_road_ids ON generated.sa_pop_grid USING GIN (road_ids);
ANALYZE generated.sa_pop_grid (road_ids);
  ",
  connection = connection
)
```

### 9. Reachable roads scripts

This is the core of the whole BNA analysis, where the actual network analysis is performed. This step might take some computation time. It is again the same as PfB, and can be reviewed with more detail on the *Rmd* file. It basically uses *pgrouting*, therefore the Dijkstra algorithm to compute the **driving distance** considering the configuration established on step 7. It does it for the two levels of traffic stress:

##### > High stress

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS generated.sa_reachable_roads_high_stress;

CREATE TABLE generated.sa_reachable_roads_high_stress (
    id SERIAL PRIMARY KEY,
    base_road INT,
    target_road INT,
    total_cost FLOAT
);

SELECT * FROM generated.sa_reachable_roads_high_stress;
```

```{sql, connection = connection, output.var = "output", include = FALSE}
INSERT INTO generated.sa_reachable_roads_high_stress (
    base_road,
    target_road,
    total_cost
)
SELECT  r1.road_id,
        v2.road_id,
        sheds.agg_cost
FROM    received.sa_ways r1,
        received.sa_ways_net_vert v1,
        received.sa_ways_net_vert v2,
        pgr_drivingDistance('
            SELECT  link_id AS id,
                    source_vert AS source,
                    target_vert AS target,
                    link_cost AS cost
            FROM    received.sa_ways_net_link',
            v1.vert_id,
            ?biking_distance, --value used in PfB approach, might change later, it is in meters and assumes a max 10 minute trip at 10mph
            directed := true
        ) sheds
--WHERE r1.road_id % :thread_num = :thread_no
--AND
WHERE
EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(b.geometry,r1.geom)
)
AND     r1.road_id = v1.road_id
AND     v2.vert_id = sheds.node;

SELECT * FROM generated.sa_reachable_roads_high_stress;
```

```{sql, connection = connection, output.var = "output", include = FALSE}
CREATE UNIQUE INDEX IF NOT EXISTS idx_sa_rchblrdshistrss_b ON generated.sa_reachable_roads_high_stress (base_road, target_road);
CREATE INDEX IF NOT EXISTS idx_sa_rchblrdshistrss_t ON generated.sa_reachable_roads_high_stress (target_road);

-- check on this, does not work good because: Key (base_road, target_road)=(1798, 3193) is duplicated.
```

```{r, include = FALSE, warning = FALSE}
library(sqldf)
sqldf(
  "
VACUUM ANALYZE generated.sa_reachable_roads_high_stress;
  ",
  connection = connection
)

## I run this with the library because R does not allow sql code without select output
## Also, SQL does not allow to run a VACUUM ANALYZE as a series of queries, so it has to be alone. 
```

##### > Low stress
```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS generated.sa_reachable_roads_low_stress;

CREATE TABLE generated.sa_reachable_roads_low_stress (
    id SERIAL PRIMARY KEY,
    base_road INT,
    target_road INT,
    total_cost FLOAT
);

SELECT * FROM generated.sa_reachable_roads_low_stress;
```

```{sql, connection = connection, output.var = "output", include = FALSE}
INSERT INTO generated.sa_reachable_roads_low_stress (
    base_road,
    target_road,
    total_cost
)
SELECT  r1.road_id,
        v2.road_id,
        sheds.agg_cost
FROM    received.sa_ways r1,
        received.sa_ways_net_vert v1,
        received.sa_ways_net_vert v2,
        pgr_drivingDistance('
            SELECT  link_id AS id,
                    source_vert AS source,
                    target_vert AS target,
                    link_cost AS cost
            FROM    received.sa_ways_net_link
            WHERE   link_stress = 1',
            v1.vert_id,
            ?biking_distance,
            directed := true
        ) sheds
--WHERE r1.road_id % :thread_num = :thread_no
--AND
WHERE
EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(b.geometry,r1.geom)
)
AND     r1.road_id = v1.road_id
AND     v2.vert_id = sheds.node;

SELECT * FROM generated.sa_reachable_roads_low_stress;
```

```{sql, connection = connection, output.var = "output", include = FALSE}
CREATE INDEX IF NOT EXISTS idx_sa_rchblrdslowstrss_b ON generated.sa_reachable_roads_low_stress (base_road);
CREATE INDEX IF NOT EXISTS idx_sa_rchblrdslowstrss_t ON generated.sa_reachable_roads_low_stress (target_road);

SELECT * FROM generated.sa_reachable_roads_low_stress;
```

```{r, include = FALSE, warning = FALSE}
library(sqldf)
sqldf(
  "
VACUUM ANALYZE generated.sa_reachable_roads_low_stress (base_road,target_road);
  ",
  connection = connection
)

## I run this with the library because R does not allow sql code without select output
## Also, SQL does not allow to run a VACUUM ANALYZE as a series of queries, so it has to be alone. 
```

### 10. Establish connected population grids and compute their accessibility

On this step basically four procedures take place:

#### - Connect population grids

Where a new table `sa_connected_pop_grid` is created to summarize the connected cells by establishing them as source and target, including if they are connected by the low or high stress network, and obtaining the minimum the costs between cells. 

```{sql, connection = connection, include = FALSE}

DROP TABLE IF EXISTS generated.sa_connected_pop_grid;

CREATE TABLE generated.sa_connected_pop_grid (
    id SERIAL PRIMARY KEY,
    source_cellid VARCHAR(18),
    target_cellid VARCHAR(18),
    low_stress BOOLEAN,
    low_stress_cost INT,
    high_stress BOOLEAN,
    high_stress_cost INT
);

INSERT INTO generated.sa_connected_pop_grid (
    source_cellid, target_cellid,
    low_stress, low_stress_cost, high_stress, high_stress_cost
)
SELECT  source.cell_id,
        target.cell_id,
        FALSE,
        (
            SELECT  MIN(ls.total_cost)
            FROM    generated.sa_reachable_roads_low_stress ls
            WHERE   ls.base_road = ANY(source.road_ids)
            AND     ls.target_road = ANY(target.road_ids)
        ),
        TRUE,
        (
            SELECT  MIN(hs.total_cost)
            FROM    generated.sa_reachable_roads_low_stress hs --They take it from the low stress because these roads can also be accessed by cars. Doing it with high stress takes a lot of time because they are like 2 million records, while low are 300 thousand. This is why they update afterwards. 
            WHERE   hs.base_road = ANY(source.road_ids)
            AND     hs.target_road = ANY(target.road_ids)
        )
FROM    generated.sa_pop_grid source,
        generated.sa_pop_grid target,
        received.sa_boundary
WHERE   ST_Intersects(source.geometry,received.sa_boundary.geometry)
AND     ST_DWithin(source.geometry,target.geometry,?biking_distance);

-- set low_stress
UPDATE  generated.sa_connected_pop_grid
SET     low_stress = TRUE
WHERE   EXISTS (
            SELECT  1
            FROM    generated.sa_pop_grid source,
                    generated.sa_pop_grid target
            WHERE   generated.sa_connected_pop_grid.source_cellid = source.cell_id
            AND     generated.sa_connected_pop_grid.target_cellid = target.cell_id
            AND     source.road_ids && target.road_ids
        )
OR      (
            low_stress_cost IS NOT NULL
        AND CASE    WHEN COALESCE(high_stress_cost,0) = 0 THEN TRUE
                    ELSE low_stress_cost::FLOAT / high_stress_cost <= 1.25
                    END
        );
        
SELECT * FROM generated.sa_connected_pop_grid;
```

```{r, include = FALSE}
library(sqldf)
sqldf(
  "
-- indexes
CREATE UNIQUE INDEX idx_sa_cellpairs ON generated.sa_connected_pop_grid (source_cellid,target_cellid);
CREATE INDEX IF NOT EXISTS idx_sa_cellpairs_lstress ON generated.sa_connected_pop_grid (low_stress) WHERE low_stress IS TRUE;
CREATE INDEX IF NOT EXISTS idx_sa_cellpairs_hstress ON generated.sa_connected_pop_grid (high_stress) WHERE high_stress IS TRUE;
ANALYZE generated.sa_connected_pop_grid;
  ",
  connection = connection
)
## I run this with the library because R does not allow sql code without select output
## Also, SQL does not allow to run a VACUUM ANALYZE as a series of queries, so it has to be alone. 
```

#### - Compute population access

The access computation on this step fills up the `sa_pop_grid` table created on *step 8*, according to the [PfB methodology](https://bna.peopleforbikes.org/#/methodology).

To compute access on this an the next step, a weighting procedure is used, as the methodology of PfB does, which can be accessed [here](https://s3.amazonaws.com/pfb-public-documents/Scoring.categories.xlsx). 

A quick glance of the weights used, mainly for *step 11*:

```{r, echo = FALSE, warning = FALSE}
library(kableExtra)
tbl <- data.frame(
  scorcat = cell_spec(
    c(
      rep("People = 15",1),
      rep("Opportunity = 20",4),
      rep("Core Services = 20",6),
      rep("Recreation = 15",3),
      rep("Retail = 15",1),
      rep("Transit = 15",1)
    )
  ),
  measure = cell_spec(
    c(
      "Population = N/A",
      "Employment = 35",
      "K-12 Education = 35",
      "Technical/vocational school = 10",
      "Higher Education = 20",
      "Doctor offices/clinics = 20",
      "Dentist offices = 10",
      "Hospitals = 20",
      "Pharmacies = 10",
      "Supermarkets = 25",
      "Social services = 15",
      "Parks = 40",
      "Recreational trails = 35",
      "Community centers = 25",
      "Retail shopping = N/A",
      "Station/transit centers = N/A"
    )
  )
)

colnames(tbl) <- c("Scoring Category", "Measure")

kable(tbl, align = "c", escape = FALSE) %>%
  kable_styling("striped", "bordered", font_size = 10, full_width = F) %>%
  collapse_rows(columns = 1, valign = "top")
```

It is important to note that this reproduction of the BNA for Europe does not include *employment* data, as until now, I have not located a source to provide this information as open data for the whole Europe. Therefore, the final results will show this category but with 0 or NA values. 

```{r, include = FALSE}
## Establish variables to give scores to population access. 
max_score = 1
step1 = 0.03
score1 = 0.1
step2 = 0.2
score2 = 0.4
step3 = 0.5
score3 = 0.8
```

```{sql pop, connection = connection, output.var = "output", include = FALSE}
-- low stress access
UPDATE  generated.sa_pop_grid
SET     pop_low_stress = (
            SELECT  SUM(blocks2.partial_p)
            FROM    generated.sa_pop_grid blocks2
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid cb
                        WHERE   cb.source_cellid = generated.sa_pop_grid.cell_id
                        AND     cb.target_cellid = blocks2.cell_id
                        AND     cb.low_stress
            )
        ),
        pop_high_stress = (
            SELECT  SUM(blocks2.partial_p)
            FROM    generated.sa_pop_grid blocks2
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid cb
                        WHERE   cb.source_cellid = generated.sa_pop_grid.cell_id
                        AND     cb.target_cellid = blocks2.cell_id
            )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set score
UPDATE  generated.sa_pop_grid
SET     pop_score = CASE
                    WHEN pop_high_stress IS NULL THEN NULL
                    WHEN pop_high_stress = 0 THEN NULL
                    WHEN pop_low_stress = 0 THEN 0
                    WHEN pop_high_stress = pop_low_stress THEN ?max_score
                    WHEN ?step1 = 0 THEN ?max_score * pop_low_stress::FLOAT / pop_high_stress
                    WHEN pop_low_stress::FLOAT / pop_high_stress = ?step3 THEN ?score3
                    WHEN pop_low_stress::FLOAT / pop_high_stress = ?step2 THEN ?score2
                    WHEN pop_low_stress::FLOAT / pop_high_stress = ?step1 THEN ?score1
                    WHEN pop_low_stress::FLOAT / pop_high_stress > ?step3
                        THEN    ?score3
                                + (?max_score - ?score3)
                                * (
                                    (pop_low_stress::FLOAT / pop_high_stress - ?step3)
                                    / (1 - ?step3)
                                )
                    WHEN pop_low_stress::FLOAT / pop_high_stress > ?step2
                        THEN    ?score2
                                + (?score3 - ?score2)
                                * (
                                    (pop_low_stress::FLOAT / pop_high_stress - ?step2)
                                    / (?step3 - ?step2)
                                )
                    WHEN pop_low_stress::FLOAT / pop_high_stress > ?step1
                        THEN    ?score1
                                + (?score2 - ?score1)
                                * (
                                    (pop_low_stress::FLOAT / pop_high_stress - ?step1)
                                    / (?step2 - ?step1)
                                )
                    ELSE        ?score1
                                * (
                                    (pop_low_stress::FLOAT / pop_high_stress)
                                    / ?step1
                                )
                    END;
                    
SELECT * FROM generated.sa_pop_grid;                    
```

#### - Extract common destinations 

Which uses the osm polygons and points generated by `osm2pgsql`. The destinations included are:

```{r, include = FALSE}
cluster_colleges = 100
cluster_community_centers = 50
cluster_doctors = 50
cluster_dentists = 50
cluster_hospitals = 50
cluster_pharmacies = 50
cluster_parks = 50
cluster_retail = 50
cluster_transit = 75
cluster_universities = 150
```

##### > Colleges

```{sql, connection = connection, output.var = "output", include = FALSE}
----------------------------------------
DROP TABLE IF EXISTS destinations.sa_colleges;

CREATE TABLE destinations.sa_colleges (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    college_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_colleges (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_colleges)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity = 'college';

-- set points on polygons
UPDATE  destinations.sa_colleges
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_colleges_geomply ON destinations.sa_colleges USING GIST (geom_poly);
ANALYZE destinations.sa_colleges (geom_poly);

-- insert points
INSERT INTO destinations.sa_colleges (
    osm_id, college_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'college'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_colleges s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_colleges_geompt ON destinations.sa_colleges USING GIST (geom_pt);
ANALYZE destinations.sa_colleges (geom_pt);

-- set cell_id
UPDATE  destinations.sa_colleges
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_colleges.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_colleges.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_destinations_sa_colleges_cell_id ON destinations.sa_colleges USING GIN (cell_id);
ANALYZE destinations.sa_colleges (cell_id);

SELECT * FROM destinations.sa_colleges;
```

##### > Community centers

```{sql, connection = connection, output.var = "output", include = FALSE}

DROP TABLE IF EXISTS destinations.sa_community_centers;

CREATE TABLE destinations.sa_community_centers (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    center_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_community_centers (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_community_centers)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity IN ('community_centre','community_center');

-- set points on polygons
UPDATE  destinations.sa_community_centers
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_community_centers_geomply ON destinations.sa_community_centers USING GIST (geom_poly);
ANALYZE destinations.sa_community_centers (geom_poly);

-- insert points
INSERT INTO destinations.sa_community_centers (
    osm_id, center_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity IN ('community_centre','community_center')
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_community_centers s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_community_centers_geompt ON destinations.sa_community_centers USING GIST (geom_pt);
ANALYZE destinations.sa_community_centers (geom_pt);

-- set cell_id
UPDATE  destinations.sa_community_centers
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_community_centers.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_community_centers_cell_id ON destinations.sa_community_centers USING GIN (cell_id);
ANALYZE destinations.sa_community_centers (cell_id);

SELECT * FROM destinations.sa_community_centers;
```

##### > Dentists

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_dentists;

CREATE TABLE destinations.sa_dentists (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    dentists_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_dentists (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_dentists)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity = 'dentist';

-- set points on polygons
UPDATE  destinations.sa_dentists
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_dentists_geomply ON destinations.sa_dentists USING GIST (geom_poly);
ANALYZE destinations.sa_dentists (geom_poly);

-- insert points
INSERT INTO destinations.sa_dentists (
    osm_id, dentists_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'dentist'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_dentists s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_dentists_geompt ON destinations.sa_dentists USING GIST (geom_pt);
ANALYZE destinations.sa_dentists (geom_pt);

-- set cell_id
UPDATE  destinations.sa_dentists
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_dentists.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_dentists.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_dentists_cell_id ON destinations.sa_dentists USING GIN (cell_id);
ANALYZE destinations.sa_dentists (cell_id);

SELECT * FROM destinations.sa_dentists;

```

##### > Doctors

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_doctors;

CREATE TABLE destinations.sa_doctors (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    doctors_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_doctors (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_doctors)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity IN ('clinic','doctors');

-- set points on polygons
UPDATE  destinations.sa_doctors
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_doctors_geomply ON destinations.sa_doctors USING GIST (geom_poly);
ANALYZE destinations.sa_doctors (geom_poly);

-- insert points
INSERT INTO destinations.sa_doctors (
    osm_id, doctors_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity IN ('clinic','doctors')
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_doctors s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_doctors_geompt ON destinations.sa_doctors USING GIST (geom_pt);
ANALYZE destinations.sa_doctors (geom_pt);

-- set cell_id
UPDATE  destinations.sa_doctors
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_doctors.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_doctors.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_doctors_cell_id ON destinations.sa_doctors USING GIN (cell_id);
ANALYZE destinations.sa_doctors (cell_id);
SELECT * FROM destinations.sa_doctors;
```

##### > Hospitals 

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_hospitals;

CREATE TABLE destinations.sa_hospitals (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    hospital_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_hospitals (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_hospitals)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity IN ('hospitals','hospital');

-- set points on polygons
UPDATE  destinations.sa_hospitals
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_hospitals_geomply ON destinations.sa_hospitals USING GIST (geom_poly);
ANALYZE destinations.sa_hospitals (geom_poly);

-- insert points
INSERT INTO destinations.sa_hospitals (
    osm_id, hospital_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity IN ('hospitals','hospital')
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_hospitals s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_hospitals_geompt ON destinations.sa_hospitals USING GIST (geom_pt);
ANALYZE destinations.sa_hospitals (geom_pt);

-- set cell_id
UPDATE  destinations.sa_hospitals
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_hospitals.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_hospitals_cell_id ON destinations.sa_hospitals USING GIN (cell_id);
ANALYZE destinations.sa_hospitals (cell_id);
SELECT * FROM destinations.sa_hospitals;
```

##### > Parks

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_parks;

CREATE TABLE destinations.sa_parks (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    park_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_parks (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_parks)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity = 'park'
        OR leisure = 'park'
        OR leisure = 'nature_reserve'
        OR leisure = 'playground';

-- set points on polygons
UPDATE  destinations.sa_parks
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_parks_geomply ON destinations.sa_parks USING GIST (geom_poly);
ANALYZE destinations.sa_parks (geom_poly);

-- insert points
INSERT INTO destinations.sa_parks (
    osm_id, park_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   (
            amenity = 'park'
        OR  leisure = 'park'
        OR  leisure = 'nature_reserve'
        OR  leisure = 'playground'
        )
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_parks s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_parks_geompt ON destinations.sa_parks USING GIST (geom_pt);
ANALYZE destinations.sa_parks (geom_pt);

-- set cell_id
UPDATE  destinations.sa_parks
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_parks.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_parks.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_parks_cell_id ON destinations.sa_parks USING GIN (cell_id);
ANALYZE destinations.sa_parks (cell_id);
SELECT * FROM destinations.sa_parks;
```

##### > Pharmacies

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_pharmacies;

CREATE TABLE destinations.sa_pharmacies (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    pharmacy_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_pharmacies (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_pharmacies)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity = 'pharmacy';

-- set points on polygons
UPDATE  destinations.sa_pharmacies
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_pharmacies_geomply ON destinations.sa_pharmacies USING GIST (geom_poly);
ANALYZE destinations.sa_pharmacies (geom_poly);

-- insert points
INSERT INTO destinations.sa_pharmacies (
    osm_id, pharmacy_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'pharmacy'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_pharmacies s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_pharmacies_geompt ON destinations.sa_pharmacies USING GIST (geom_pt);
ANALYZE destinations.sa_pharmacies (geom_pt);

-- set cell_id
UPDATE  destinations.sa_pharmacies
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_pharmacies.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_pharmacies_cell_id ON destinations.sa_pharmacies USING GIN (cell_id);
ANALYZE destinations.sa_pharmacies (cell_id);
SELECT * FROM destinations.sa_pharmacies;
```

##### > Retail

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_retail;

CREATE TABLE destinations.sa_retail (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert
INSERT INTO destinations.sa_retail (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_retail)),3),0))
FROM    received.sa_full_polygon
WHERE   landuse = 'retail';

-- set points on polygons
UPDATE  destinations.sa_retail
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_retail_geomply ON destinations.sa_retail USING GIST (geom_poly);
ANALYZE destinations.sa_retail (geom_poly);

-- set cell_id
UPDATE  destinations.sa_retail
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_retail_cell_id ON destinations.sa_retail USING GIN (cell_id);
ANALYZE destinations.sa_retail (cell_id);
SELECT * FROM destinations.sa_retail;
```

##### > Schools

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_schools;

CREATE TABLE destinations.sa_schools (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    school_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(polygon, ?sa_crs)
);

-- insert points from polygons
INSERT INTO destinations.sa_schools (
    osm_id, school_name, geom_pt, geom_poly
)
SELECT  osm_id,
        name,
        ST_Centroid(way),
        way
FROM    received.sa_full_polygon
WHERE   amenity = 'school';

-- remove subareas that are mistakenly designated as amenity=school
DELETE FROM destinations.sa_schools
WHERE   EXISTS (
            SELECT  1
            FROM    destinations.sa_schools s
            WHERE   ST_Contains(s.geom_poly,destinations.sa_schools.geom_poly)
            AND     s.id != destinations.sa_schools.id
);

-- index
CREATE INDEX sidx_sa_schools_geomply ON destinations.sa_schools USING GIST (geom_poly);
ANALYZE destinations.sa_schools (geom_poly);

-- insert points
INSERT INTO destinations.sa_schools (
    osm_id, school_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'school'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_schools s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_schools_geompt ON destinations.sa_schools USING GIST (geom_pt);
ANALYZE destinations.sa_schools (geom_pt);

-- set cell_id
UPDATE  destinations.sa_schools
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_schools.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_schools.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_schools_cell_id ON destinations.sa_schools USING GIN (cell_id);
ANALYZE destinations.sa_schools (cell_id);
SELECT * FROM destinations.sa_schools;
```

##### > Social services

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_social_services;

CREATE TABLE destinations.sa_social_services (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    service_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(polygon, ?sa_crs)
);

-- insert points from polygons
INSERT INTO destinations.sa_social_services (
    osm_id, service_name, geom_pt, geom_poly
)
SELECT  osm_id,
        name,
        ST_Centroid(way),
        way
FROM    received.sa_full_polygon
WHERE   amenity = 'social_facility';

-- remove subareas that are already covered
DELETE FROM destinations.sa_social_services
WHERE   EXISTS (
            SELECT  1
            FROM    destinations.sa_social_services s
            WHERE   ST_Contains(s.geom_poly,destinations.sa_social_services.geom_poly)
            AND     s.id != destinations.sa_social_services.id
);

-- index
CREATE INDEX sidx_sa_social_services_geomply ON destinations.sa_social_services USING GIST (geom_poly);
ANALYZE destinations.sa_social_services (geom_poly);

-- insert points
INSERT INTO destinations.sa_social_services (
    osm_id, service_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'social_facility'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_social_services s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_social_services_geompt ON destinations.sa_social_services USING GIST (geom_pt);
ANALYZE destinations.sa_social_services (geom_pt);

-- set cell_id
UPDATE  destinations.sa_social_services
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_social_services.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_social_services.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_social_services_cell_id ON destinations.sa_social_services USING GIN (cell_id);
ANALYZE destinations.sa_social_services (cell_id);
SELECT * FROM destinations.sa_social_services;
```

##### > Supermarkets

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_supermarkets;

CREATE TABLE destinations.sa_supermarkets (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    supermarket_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(polygon, ?sa_crs)
);

-- insert points from polygons
INSERT INTO destinations.sa_supermarkets (
    osm_id, supermarket_name, geom_pt, geom_poly
)
SELECT  osm_id,
        name,
        ST_Centroid(way),
        way
FROM    received.sa_full_polygon
WHERE   shop = 'supermarket';

-- remove subareas that are already covered
DELETE FROM destinations.sa_supermarkets
WHERE   EXISTS (
            SELECT  1
            FROM    destinations.sa_supermarkets s
            WHERE   ST_Contains(s.geom_poly,destinations.sa_supermarkets.geom_poly)
            AND     s.id != destinations.sa_supermarkets.id
);

-- index
CREATE INDEX sidx_sa_supermarkets_geomply ON destinations.sa_supermarkets USING GIST (geom_poly);
ANALYZE destinations.sa_supermarkets (geom_poly);

-- insert points
INSERT INTO destinations.sa_supermarkets (
    osm_id, supermarket_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   shop = 'supermarket'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_supermarkets s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_supermarkets_geompt ON destinations.sa_supermarkets USING GIST (geom_pt);
ANALYZE destinations.sa_supermarkets (geom_pt);

-- set cell_id
UPDATE  destinations.sa_supermarkets
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_supermarkets.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_supermarkets_cell_id ON destinations.sa_supermarkets USING GIN (cell_id);
ANALYZE destinations.sa_supermarkets (cell_id);
SELECT * FROM destinations.sa_supermarkets;
```

##### > Transit

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_transit;

CREATE TABLE destinations.sa_transit (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    transit_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(polygon, ?sa_crs)
);

-- insert points from polygons
INSERT INTO destinations.sa_transit (
    osm_id, transit_name, geom_pt, geom_poly
)
SELECT  osm_id,
        name,
        ST_Centroid(way),
        way
FROM    received.sa_full_polygon
WHERE   amenity = 'bus_station'
OR      railway = 'station'
OR      public_transport = 'station';

-- remove subareas
DELETE FROM destinations.sa_transit
WHERE   EXISTS (
            SELECT  1
            FROM    destinations.sa_transit s
            WHERE   ST_Contains(s.geom_poly,destinations.sa_transit.geom_poly)
            AND     s.id != destinations.sa_transit.id
);

-- index
CREATE INDEX sidx_sa_transit_geomply ON destinations.sa_transit USING GIST (geom_poly);
ANALYZE destinations.sa_transit (geom_poly);

-- insert points
INSERT INTO destinations.sa_transit (
    geom_pt
)
SELECT  ST_Centroid(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_transit)),1))
FROM    received.sa_full_point
WHERE   (
            amenity = 'bus_station'
        OR  railway = 'station'
        OR  public_transport = 'station'
        )
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_transit s
            WHERE   ST_DWithin(s.geom_poly,received.sa_full_point.way,50)
        );

-- index
CREATE INDEX sidx_sa_transit_geompt ON destinations.sa_transit USING GIST (geom_pt);
ANALYZE destinations.sa_transit (geom_pt);

-- set cell_id
UPDATE  destinations.sa_transit
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_transit.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_transit.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_transit_cell_id ON destinations.sa_transit USING GIN (cell_id);
ANALYZE destinations.sa_transit (cell_id);
SELECT * FROM destinations.sa_transit;
```

##### > Universities

```{sql, connection = connection, output.var = "output", include = FALSE}
DROP TABLE IF EXISTS destinations.sa_universities;

CREATE TABLE destinations.sa_universities (
    id SERIAL PRIMARY KEY,
    cell_id CHARACTER VARYING(18)[],
    osm_id BIGINT,
    college_name TEXT,
    pop_low_stress INT,
    pop_high_stress INT,
    pop_score FLOAT,
    geom_pt geometry(point, ?sa_crs),
    geom_poly geometry(multipolygon, ?sa_crs)
);

-- insert polygons
INSERT INTO destinations.sa_universities (
    geom_poly
)
SELECT  ST_Multi(ST_Buffer(ST_CollectionExtract(unnest(ST_ClusterWithin(way,?cluster_universities)),3),0))
FROM    received.sa_full_polygon
WHERE   amenity = 'university';

-- set points on polygons
UPDATE  destinations.sa_universities
SET     geom_pt = ST_Centroid(geom_poly);

-- index
CREATE INDEX sidx_sa_universities_geomply ON destinations.sa_universities USING GIST (geom_poly);
ANALYZE destinations.sa_universities (geom_poly);

-- insert points
INSERT INTO destinations.sa_universities (
    osm_id, college_name, geom_pt
)
SELECT  osm_id,
        name,
        way
FROM    received.sa_full_point
WHERE   amenity = 'university'
AND     NOT EXISTS (
            SELECT  1
            FROM    destinations.sa_universities s
            WHERE   ST_Intersects(s.geom_poly,received.sa_full_point.way)
        );

-- index
CREATE INDEX sidx_sa_universities_geompt ON destinations.sa_universities USING GIST (geom_pt);
ANALYZE destinations.sa_universities (geom_pt);

-- set cell_id
UPDATE  destinations.sa_universities
SET     cell_id = array((
            SELECT  cb.cell_id
            FROM    generated.sa_pop_grid cb
            WHERE   ST_Intersects(destinations.sa_universities.geom_poly,cb.geometry)
            OR      ST_Intersects(destinations.sa_universities.geom_pt,cb.geometry)
        ));

-- block index
CREATE INDEX IF NOT EXISTS aidx_sa_universities_cell_id ON destinations.sa_universities USING GIN (cell_id);
ANALYZE destinations.sa_universities (cell_id);
SELECT * FROM destinations.sa_universities;
```

#### - Compute access to common destinations

Where the access to the destinations established before is computed. Access to recreational trails and bike paths is also included.

```{r, include = FALSE, warning = FALSE}

max_score = 1

## Scores first group: colleges, hospitals, social services, universities
Afirst = 0.7
Asecond = 0
Athird = 0

## Scores second group: community centers, dentists, pharmacies, retail
Bfirst = 0.4 
Bsecond = 0.2 
Bthird = 0.1 

## Scores third group: parks, schools
Cfirst = 0.3 
Csecond = 0.2 
Cthird = 0.2 

## Scores fourth group: supermarkets
Dfirst = 0.6 
Dsecond = 0.2 
Dthird = 0

## Scores fifth group: trails
Efirst = 0.7 
Esecond = 0.2 
Ethird = 0
min_path_length=4800 
min_bbox_length=3300 

## Scores sixth group: transit
Ffirst = 0.6 
Fsecond = 0 
Fthird = 0

```

```{sql colleges, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     colleges_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_colleges
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_colleges.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        colleges_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_colleges
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_colleges.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     colleges_score =    CASE
                            WHEN colleges_high_stress IS NULL THEN NULL
                            WHEN colleges_high_stress = 0 THEN NULL
                            WHEN colleges_low_stress = 0 THEN 0
                            WHEN colleges_high_stress = colleges_low_stress THEN ?max_score
                            WHEN ?Afirst = 0 THEN colleges_low_stress::FLOAT / colleges_high_stress
                            WHEN ?Asecond = 0
                                THEN    ?Afirst
                                        + ((?max_score - ?Afirst) * (colleges_low_stress::FLOAT - 1))
                                        / (colleges_high_stress - 1)
                            WHEN ?Athird = 0
                                THEN    CASE
                                        WHEN colleges_low_stress = 1 THEN ?Afirst
                                        WHEN colleges_low_stress = 2 THEN ?Afirst + ?Asecond
                                        ELSE ?Afirst + ?Asecond
                                                + ((?max_score - ?Afirst - ?Asecond) * (colleges_low_stress::FLOAT - 2))
                                                / (colleges_high_stress - 2)
                                        END
                            ELSE        CASE
                                        WHEN colleges_low_stress = 1 THEN ?Afirst
                                        WHEN colleges_low_stress = 2 THEN ?Afirst + ?Asecond
                                        WHEN colleges_low_stress = 3 THEN ?Afirst + ?Asecond + ?Athird
                                        ELSE ?Afirst + ?Asecond + ?Athird
                                                + ((?max_score - ?Afirst - ?Asecond - ?Athird) * (colleges_low_stress::FLOAT - 3))
                                                / (colleges_high_stress - 3)
                                        END
                            END;

-- set population shed for each college in the neighborhood
UPDATE  destinations.sa_colleges
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_colleges.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_colleges.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_colleges.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_colleges
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```


```{sql comcen, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     community_centers_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_community_centers
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_community_centers.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        community_centers_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_community_centers
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_community_centers.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     community_centers_score =   CASE
                                    WHEN community_centers_high_stress IS NULL THEN NULL
                                    WHEN community_centers_high_stress = 0 THEN NULL
                                    WHEN community_centers_low_stress = 0 THEN 0
                                    WHEN community_centers_high_stress = community_centers_low_stress THEN ?max_score
                                    WHEN ?Bfirst = 0 THEN community_centers_low_stress::FLOAT / community_centers_high_stress
                                    WHEN ?Bsecond = 0
                                        THEN    ?Bfirst
                                                + ((?max_score - ?Bfirst) * (community_centers_low_stress::FLOAT - 1))
                                                / (community_centers_high_stress - 1)
                                    WHEN ?Bthird = 0
                                        THEN    CASE
                                                WHEN community_centers_low_stress = 1 THEN ?Bfirst
                                                WHEN community_centers_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                                ELSE ?Bfirst + ?Bsecond
                                                        + ((?max_score - ?Bfirst - ?Bsecond) * (community_centers_low_stress::FLOAT - 2))
                                                        / (community_centers_high_stress - 2)
                                                END
                                    ELSE        CASE
                                                WHEN community_centers_low_stress = 1 THEN ?Bfirst
                                                WHEN community_centers_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                                WHEN community_centers_low_stress = 3 THEN ?Bfirst + ?Bsecond + ?Bthird
                                                ELSE ?Bfirst + ?Bsecond + ?Bthird
                                                        + ((?max_score - ?Bfirst - ?Bsecond - ?Bthird) * (community_centers_low_stress::FLOAT - 3))
                                                        / (community_centers_high_stress - 3)
                                                END
                                    END;

-- set population shed for each community center in the neighborhood
UPDATE  destinations.sa_community_centers
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_community_centers.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_community_centers.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_community_centers
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql dentist, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     dentists_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_dentists
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_dentists.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        dentists_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_dentists
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_dentists.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     dentists_score =    CASE
                            WHEN dentists_high_stress IS NULL THEN NULL
                            WHEN dentists_high_stress = 0 THEN NULL
                            WHEN dentists_low_stress = 0 THEN 0
                            WHEN dentists_high_stress = dentists_low_stress THEN ?max_score
                            WHEN ?Bfirst = 0 THEN dentists_low_stress::FLOAT / dentists_high_stress
                            WHEN ?Bsecond = 0
                                THEN    ?Bfirst
                                        + ((?max_score - ?Bfirst) * (dentists_low_stress::FLOAT - 1))
                                        / (dentists_high_stress - 1)
                            WHEN ?Bthird = 0
                                THEN    CASE
                                        WHEN dentists_low_stress = 1 THEN ?Bfirst
                                        WHEN dentists_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                        ELSE ?Bfirst + ?Bsecond
                                                + ((?max_score - ?Bfirst - ?Bsecond) * (dentists_low_stress::FLOAT - 2))
                                                / (dentists_high_stress - 2)
                                        END
                            ELSE        CASE
                                        WHEN dentists_low_stress = 1 THEN ?Bfirst
                                        WHEN dentists_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                        WHEN dentists_low_stress = 3 THEN ?Bfirst + ?Bsecond + ?Bthird
                                        ELSE ?Bfirst + ?Bsecond + ?Bthird
                                                + ((?max_score - ?Bfirst - ?Bsecond - ?Bthird) * (dentists_low_stress::FLOAT - 3))
                                                / (dentists_high_stress - 3)
                                        END
                            END;

-- set population shed for each dentists destination in the neighborhood
UPDATE  destinations.sa_dentists
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_dentists.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_dentists.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_dentists.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_dentists
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql doctors, connection = connection, output.var = "output" , include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     doctors_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_doctors
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_doctors.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        doctors_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_doctors
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_doctors.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     doctors_score = CASE
                        WHEN doctors_high_stress IS NULL THEN NULL
                        WHEN doctors_high_stress = 0 THEN NULL
                        WHEN doctors_low_stress = 0 THEN 0
                        WHEN doctors_high_stress = doctors_low_stress THEN ?max_score
                        WHEN ?Bfirst = 0 THEN doctors_low_stress::FLOAT / doctors_high_stress
                        WHEN ?Bsecond = 0
                            THEN    ?Bfirst
                                    + ((?max_score - ?Bfirst) * (doctors_low_stress::FLOAT - 1))
                                    / (doctors_high_stress - 1)
                        WHEN ?Bthird = 0
                            THEN    CASE
                                    WHEN doctors_low_stress = 1 THEN ?Bfirst
                                    WHEN doctors_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                    ELSE ?Bfirst + ?Bsecond
                                            + ((?max_score - ?Bfirst - ?Bsecond) * (doctors_low_stress::FLOAT - 2))
                                            / (doctors_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN doctors_low_stress = 1 THEN ?Bfirst
                                    WHEN doctors_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                    WHEN doctors_low_stress = 3 THEN ?Bfirst + ?Bsecond + ?Bthird
                                    ELSE ?Bfirst + ?Bsecond + ?Bthird
                                            + ((?max_score - ?Bfirst - ?Bsecond - ?Bthird) * (doctors_low_stress::FLOAT - 3))
                                            / (doctors_high_stress - 3)
                                    END
                        END;

-- set population shed for each doctors destination in the neighborhood
UPDATE  destinations.sa_doctors
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_doctors.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_doctors.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_doctors.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_doctors
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql hospitals, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     hospitals_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_hospitals
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_hospitals.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        hospitals_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_hospitals
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_hospitals.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     hospitals_score =   CASE
                            WHEN hospitals_high_stress IS NULL THEN NULL
                            WHEN hospitals_high_stress = 0 THEN NULL
                            WHEN hospitals_low_stress = 0 THEN 0
                            WHEN hospitals_high_stress = hospitals_low_stress THEN ?max_score
                            WHEN ?Afirst = 0 THEN hospitals_low_stress::FLOAT / hospitals_high_stress
                            WHEN ?Asecond = 0
                                THEN    ?Afirst
                                        + ((?max_score - ?Afirst) * (hospitals_low_stress::FLOAT - 1))
                                        / (hospitals_high_stress - 1)
                            WHEN ?Athird = 0
                                THEN    CASE
                                        WHEN hospitals_low_stress = 1 THEN ?Afirst
                                        WHEN hospitals_low_stress = 2 THEN ?Afirst + ?Asecond
                                        ELSE ?Afirst + ?Asecond
                                                + ((?max_score - ?Afirst - ?Asecond) * (hospitals_low_stress::FLOAT - 2))
                                                / (hospitals_high_stress - 2)
                                        END
                            ELSE        CASE
                                        WHEN hospitals_low_stress = 1 THEN ?Afirst
                                        WHEN hospitals_low_stress = 2 THEN ?Afirst + ?Asecond
                                        WHEN hospitals_low_stress = 3 THEN ?Afirst + ?Asecond + ?Athird
                                        ELSE ?Afirst + ?Asecond + ?Athird
                                                + ((?max_score - ?Afirst - ?Asecond - ?Athird) * (hospitals_low_stress::FLOAT - 3))
                                                / (hospitals_high_stress - 3)
                                        END
                            END;

-- set population shed for each hospitals destination in the neighborhood
UPDATE  destinations.sa_hospitals
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_hospitals.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_hospitals.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_hospitals
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql parks, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     parks_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_parks
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_parks.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        parks_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_parks
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_parks.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     parks_score =   CASE
                        WHEN parks_high_stress IS NULL THEN NULL
                        WHEN parks_high_stress = 0 THEN NULL
                        WHEN parks_low_stress = 0 THEN 0
                        WHEN parks_high_stress = parks_low_stress THEN ?max_score
                        WHEN ?Cfirst = 0 THEN parks_low_stress::FLOAT / parks_high_stress
                        WHEN ?Csecond = 0
                            THEN    ?Cfirst
                                    + ((?max_score - ?Cfirst) * (parks_low_stress::FLOAT - 1))
                                    / (parks_high_stress - 1)
                        WHEN ?Cthird = 0
                            THEN    CASE
                                    WHEN parks_low_stress = 1 THEN ?Cfirst
                                    WHEN parks_low_stress = 2 THEN ?Cfirst + ?Csecond
                                    ELSE ?Cfirst + ?Csecond
                                            + ((?max_score - ?Cfirst - ?Csecond) * (parks_low_stress::FLOAT - 2))
                                            / (parks_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN parks_low_stress = 1 THEN ?Cfirst
                                    WHEN parks_low_stress = 2 THEN ?Cfirst + ?Csecond
                                    WHEN parks_low_stress = 3 THEN ?Cfirst + ?Csecond + ?Cthird
                                    ELSE ?Cfirst + ?Csecond + ?Cthird
                                            + ((?max_score - ?Cfirst - ?Csecond - ?Cthird) * (parks_low_stress::FLOAT - 3))
                                            / (parks_high_stress - 3)
                                    END
                        END;

-- set population shed for each park in the neighborhood
UPDATE  destinations.sa_parks
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_parks.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_parks.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_parks.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_parks
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql pharmacies, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     pharmacies_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_pharmacies
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_pharmacies.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        pharmacies_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_pharmacies
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_pharmacies.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     pharmacies_score =  CASE
                            WHEN pharmacies_high_stress IS NULL THEN NULL
                            WHEN pharmacies_high_stress = 0 THEN NULL
                            WHEN pharmacies_low_stress = 0 THEN 0
                            WHEN pharmacies_high_stress = pharmacies_low_stress THEN ?max_score
                            WHEN ?Bfirst = 0 THEN pharmacies_low_stress::FLOAT / pharmacies_high_stress
                            WHEN ?Bsecond = 0
                                THEN    ?Bfirst
                                        + ((?max_score - ?Bfirst) * (pharmacies_low_stress::FLOAT - 1))
                                        / (pharmacies_high_stress - 1)
                            WHEN ?Bthird = 0
                                THEN    CASE
                                        WHEN pharmacies_low_stress = 1 THEN ?Bfirst
                                        WHEN pharmacies_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                        ELSE ?Bfirst + ?Bsecond
                                                + ((?max_score - ?Bfirst - ?Bsecond) * (pharmacies_low_stress::FLOAT - 2))
                                                / (pharmacies_high_stress - 2)
                                        END
                            ELSE        CASE
                                        WHEN pharmacies_low_stress = 1 THEN ?Bfirst
                                        WHEN pharmacies_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                        WHEN pharmacies_low_stress = 3 THEN ?Bfirst + ?Bsecond + ?Bthird
                                        ELSE ?Bfirst + ?Bsecond + ?Bthird
                                                + ((?max_score - ?Bfirst - ?Bsecond - ?Bthird) * (pharmacies_low_stress::FLOAT - 3))
                                                / (pharmacies_high_stress - 3)
                                        END
                            END;

-- set population shed for each pharmacies destination in the neighborhood
UPDATE  destinations.sa_pharmacies
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_pharmacies.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_pharmacies.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_pharmacies
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql retail, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     retail_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_retail
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_retail.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        retail_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_retail
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_retail.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     retail_score =  CASE
                        WHEN retail_high_stress IS NULL THEN NULL
                        WHEN retail_high_stress = 0 THEN NULL
                        WHEN retail_low_stress = 0 THEN 0
                        WHEN retail_high_stress = retail_low_stress THEN ?max_score
                        WHEN ?Bfirst = 0 THEN retail_low_stress::FLOAT / retail_high_stress
                        WHEN ?Bsecond = 0
                            THEN    ?Bfirst
                                    + ((?max_score - ?Bfirst) * (retail_low_stress::FLOAT - 1))
                                    / (retail_high_stress - 1)
                        WHEN ?Bthird = 0
                            THEN    CASE
                                    WHEN retail_low_stress = 1 THEN ?Bfirst
                                    WHEN retail_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                    ELSE ?Bfirst + ?Bsecond
                                            + ((?max_score - ?Bfirst - ?Bsecond) * (retail_low_stress::FLOAT - 2))
                                            / (retail_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN retail_low_stress = 1 THEN ?Bfirst
                                    WHEN retail_low_stress = 2 THEN ?Bfirst + ?Bsecond
                                    WHEN retail_low_stress = 3 THEN ?Bfirst + ?Bsecond + ?Bthird
                                    ELSE ?Bfirst + ?Bsecond + ?Bthird
                                            + ((?max_score - ?Bfirst - ?Bsecond - ?Bthird) * (retail_low_stress::FLOAT - 3))
                                            / (retail_high_stress - 3)
                                    END
                        END;

-- set population shed for each retail destination in the neighborhood
UPDATE  destinations.sa_retail
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_retail.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_retail.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,b.geometry)
        );

UPDATE  destinations.sa_retail
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql schools, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     schools_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_schools
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_schools.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        schools_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_schools
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_schools.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     schools_score = CASE
                        WHEN schools_high_stress IS NULL THEN NULL
                        WHEN schools_high_stress = 0 THEN NULL
                        WHEN schools_low_stress = 0 THEN 0
                        WHEN schools_high_stress = schools_low_stress THEN ?max_score
                        WHEN ?Cfirst = 0 THEN schools_low_stress::FLOAT / schools_high_stress
                        WHEN ?Csecond = 0
                            THEN    ?Cfirst
                                    + ((?max_score - ?Cfirst) * (schools_low_stress::FLOAT - 1))
                                    / (schools_high_stress - 1)
                        WHEN ?Cthird = 0
                            THEN    CASE
                                    WHEN schools_low_stress = 1 THEN ?Cfirst
                                    WHEN schools_low_stress = 2 THEN ?Cfirst + ?Csecond
                                    ELSE ?Cfirst + ?Csecond
                                            + ((?max_score - ?Cfirst - ?Csecond) * (schools_low_stress::FLOAT - 2))
                                            / (schools_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN schools_low_stress = 1 THEN ?Cfirst
                                    WHEN schools_low_stress = 2 THEN ?Cfirst + ?Csecond
                                    WHEN schools_low_stress = 3 THEN ?Cfirst + ?Csecond + ?Cthird
                                    ELSE ?Cfirst + ?Csecond + ?Cthird
                                            + ((?max_score - ?Cfirst - ?Csecond - ?Cthird) * (schools_low_stress::FLOAT - 3))
                                            / (schools_high_stress - 3)
                                    END
                        END;

-- set population shed for each school in the neighborhood
UPDATE  destinations.sa_schools
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_schools.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_schools.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_schools.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_schools
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql socserv, connection = connection, output.var = "output", include = FALSE}

-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     social_services_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_social_services
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_social_services.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        social_services_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_social_services
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_social_services.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     social_services_score = CASE
                                WHEN social_services_high_stress IS NULL THEN NULL
                                WHEN social_services_high_stress = 0 THEN NULL
                                WHEN social_services_low_stress = 0 THEN 0
                                WHEN social_services_high_stress = social_services_low_stress THEN ?max_score
                                WHEN ?Afirst = 0 THEN social_services_low_stress::FLOAT / social_services_high_stress
                                WHEN ?Asecond = 0
                                    THEN    ?Afirst
                                            + ((?max_score - ?Afirst) * (social_services_low_stress::FLOAT - 1))
                                            / (social_services_high_stress - 1)
                                WHEN ?Athird = 0
                                    THEN    CASE
                                            WHEN social_services_low_stress = 1 THEN ?Afirst
                                            WHEN social_services_low_stress = 2 THEN ?Afirst + ?Asecond
                                            ELSE ?Afirst + ?Asecond
                                                    + ((?max_score - ?Afirst - ?Asecond) * (social_services_low_stress::FLOAT - 2))
                                                    / (social_services_high_stress - 2)
                                            END
                                ELSE        CASE
                                            WHEN social_services_low_stress = 1 THEN ?Afirst
                                            WHEN social_services_low_stress = 2 THEN ?Afirst + ?Asecond
                                            WHEN social_services_low_stress = 3 THEN ?Afirst + ?Asecond + ?Athird
                                            ELSE ?Afirst + ?Asecond + ?Athird
                                                    + ((?max_score - ?Afirst - ?Asecond - ?Athird) * (social_services_low_stress::FLOAT - 3))
                                                    / (social_services_high_stress - 3)
                                            END
                                END;

-- set population shed for each social service destination in the neighborhood
UPDATE  destinations.sa_social_services
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_social_services.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_social_services.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_social_services.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_social_services
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql supermarkets, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     supermarkets_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_supermarkets
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_supermarkets.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        supermarkets_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_supermarkets
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_supermarkets.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     supermarkets_score =    CASE
                                WHEN supermarkets_high_stress IS NULL THEN NULL
                                WHEN supermarkets_high_stress = 0 THEN NULL
                                WHEN supermarkets_low_stress = 0 THEN 0
                                WHEN supermarkets_high_stress = supermarkets_low_stress THEN ?max_score
                                WHEN ?Dfirst = 0 THEN supermarkets_low_stress::FLOAT / supermarkets_high_stress
                                WHEN ?Dsecond = 0
                                    THEN    ?Dfirst
                                            + ((?max_score - ?Dfirst) * (supermarkets_low_stress::FLOAT - 1))
                                            / (supermarkets_high_stress - 1)
                                WHEN ?Dthird = 0
                                    THEN    CASE
                                            WHEN supermarkets_low_stress = 1 THEN ?Dfirst
                                            WHEN supermarkets_low_stress = 2 THEN ?Dfirst + ?Dsecond
                                            ELSE ?Dfirst + ?Dsecond
                                                    + ((?max_score - ?Dfirst - ?Dsecond) * (supermarkets_low_stress::FLOAT - 2))
                                                    / (supermarkets_high_stress - 2)
                                            END
                                ELSE        CASE
                                            WHEN supermarkets_low_stress = 1 THEN ?Dfirst
                                            WHEN supermarkets_low_stress = 2 THEN ?Dfirst + ?Dsecond
                                            WHEN supermarkets_low_stress = 3 THEN ?Dfirst + ?Dsecond + ?Dthird
                                            ELSE ?Dfirst + ?Dsecond + ?Dthird
                                                    + ((?max_score - ?Dfirst - ?Dsecond - ?Dthird) * (supermarkets_low_stress::FLOAT - 3))
                                                    / (supermarkets_high_stress - 3)
                                            END
                                END;

-- set population shed for each supermarket in the neighborhood
UPDATE  destinations.sa_supermarkets
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_supermarkets.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_supermarkets.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_supermarkets
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql trails, connection = connection, output.var = "output", include = FALSE}
-- low stress access
UPDATE  generated.sa_pop_grid
SET     trails_low_stress = (
            SELECT  COUNT(path_id)
            FROM    generated.sa_paths
            WHERE   path_length > ?min_path_length
            AND     bbox_length > ?min_bbox_length
            AND     EXISTS (
                        SELECT  1
                        FROM    generated.sa_reachable_roads_low_stress ls
                        WHERE   ls.target_road = ANY(generated.sa_paths.road_ids)
                        AND     ls.base_road = ANY(generated.sa_pop_grid.road_ids)
            )
        ),
        trails_high_stress = (
            SELECT  COUNT(path_id)
            FROM    generated.sa_paths
            WHERE   path_length > ?min_path_length
            AND     bbox_length > ?min_bbox_length
            AND     EXISTS (
                        SELECT  1
                        FROM    generated.sa_reachable_roads_high_stress hs
                        WHERE   hs.target_road = ANY(generated.sa_paths.road_ids)
                        AND     hs.base_road = ANY(generated.sa_pop_grid.road_ids)
            )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     trails_score =  CASE
                        WHEN trails_high_stress IS NULL THEN NULL
                        WHEN trails_high_stress = 0 THEN NULL
                        WHEN trails_low_stress = 0 THEN 0
                        WHEN trails_high_stress = trails_low_stress THEN ?max_score
                        WHEN ?Efirst = 0 THEN trails_low_stress::FLOAT / trails_high_stress
                        WHEN ?Esecond = 0
                            THEN    ?Efirst
                                    + ((?max_score - ?Efirst) * (trails_low_stress::FLOAT - 1))
                                    / (trails_high_stress - 1)
                        WHEN ?Ethird = 0
                            THEN    CASE
                                    WHEN trails_low_stress = 1 THEN ?Efirst
                                    WHEN trails_low_stress = 2 THEN ?Efirst + ?Esecond
                                    ELSE ?Efirst + ?Esecond
                                            + ((?max_score - ?Efirst - ?Esecond) * (trails_low_stress::FLOAT - 2))
                                            / (trails_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN trails_low_stress = 1 THEN ?Efirst
                                    WHEN trails_low_stress = 2 THEN ?Efirst + ?Esecond
                                    WHEN trails_low_stress = 3 THEN ?Efirst + ?Esecond + ?Ethird
                                    ELSE ?Efirst + ?Esecond + ?Ethird
                                            + ((?max_score - ?Efirst - ?Esecond - ?Ethird) * (trails_low_stress::FLOAT - 3))
                                            / (trails_high_stress - 3)
                                    END
                        END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql transit, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     transit_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_transit
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_transit.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        transit_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_transit
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_transit.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     transit_score =   CASE
                        WHEN transit_high_stress IS NULL THEN NULL
                        WHEN transit_high_stress = 0 THEN NULL
                        WHEN transit_low_stress = 0 THEN 0
                        WHEN transit_high_stress = transit_low_stress THEN ?max_score
                        WHEN ?Ffirst = 0 THEN transit_low_stress::FLOAT / transit_high_stress
                        WHEN ?Fsecond = 0
                            THEN    ?Ffirst
                                    + ((?max_score - ?Ffirst) * (transit_low_stress::FLOAT - 1))
                                    / (transit_high_stress - 1)
                        WHEN ?Fthird = 0
                            THEN    CASE
                                    WHEN transit_low_stress = 1 THEN ?Ffirst
                                    WHEN transit_low_stress = 2 THEN ?Ffirst + ?Fsecond
                                    ELSE ?Ffirst + ?Fsecond
                                            + ((?max_score - ?Ffirst - ?Fsecond) * (transit_low_stress::FLOAT - 2))
                                            / (transit_high_stress - 2)
                                    END
                        ELSE        CASE
                                    WHEN transit_low_stress = 1 THEN ?Ffirst
                                    WHEN transit_low_stress = 2 THEN ?Ffirst + ?Fsecond
                                    WHEN transit_low_stress = 3 THEN ?Ffirst + ?Fsecond + ?Fthird
                                    ELSE ?Ffirst + ?Fsecond + ?Fthird
                                            + ((?max_score - ?Ffirst - ?Fsecond - ?Fthird) * (transit_low_stress::FLOAT - 3))
                                            / (transit_high_stress - 3)
                                    END
                        END;

-- set population shed for each park in the neighborhood
UPDATE  destinations.sa_transit
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_transit.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_transit.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_transit.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_transit
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;
```

```{sql universities, connection = connection, output.var = "output", include = FALSE}
-- set block-based raw numbers
UPDATE  generated.sa_pop_grid
SET     universities_low_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_universities
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_universities.cell_id)
                        AND     generated.sa_connected_pop_grid.low_stress
                    )
        ),
        universities_high_stress = (
            SELECT  COUNT(id)
            FROM    destinations.sa_universities
            WHERE   EXISTS (
                        SELECT  1
                        FROM    generated.sa_connected_pop_grid
                        WHERE   generated.sa_connected_pop_grid.source_cellid = generated.sa_pop_grid.cell_id
                        AND     generated.sa_connected_pop_grid.target_cellid = ANY(destinations.sa_universities.cell_id)
                    )
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- set block-based score
UPDATE  generated.sa_pop_grid
SET     universities_score =    CASE
                                WHEN universities_high_stress IS NULL THEN NULL
                                WHEN universities_high_stress = 0 THEN NULL
                                WHEN universities_low_stress = 0 THEN 0
                                WHEN universities_high_stress = universities_low_stress THEN ?max_score
                                WHEN ?Afirst = 0 THEN universities_low_stress::FLOAT / universities_high_stress
                                WHEN ?Asecond = 0
                                    THEN    ?Afirst
                                            + ((?max_score - ?Afirst) * (universities_low_stress::FLOAT - 1))
                                            / (universities_high_stress - 1)
                                WHEN ?Athird = 0
                                    THEN    CASE
                                            WHEN universities_low_stress = 1 THEN ?Afirst
                                            WHEN universities_low_stress = 2 THEN ?Afirst + ?Asecond
                                            ELSE ?Afirst + ?Asecond
                                                    + ((?max_score - ?Afirst - ?Asecond) * (universities_low_stress::FLOAT - 2))
                                                    / (universities_high_stress - 2)
                                            END
                                ELSE        CASE
                                            WHEN universities_low_stress = 1 THEN ?Afirst
                                            WHEN universities_low_stress = 2 THEN ?Afirst + ?Asecond
                                            WHEN universities_low_stress = 3 THEN ?Afirst + ?Asecond + ?Athird
                                            ELSE ?Afirst + ?Asecond + ?Athird
                                                    + ((?max_score - ?Afirst - ?Asecond - ?Athird) * (universities_low_stress::FLOAT - 3))
                                                    / (universities_high_stress - 3)
                                            END
                                END;

-- set population shed for each university in the neighborhood
UPDATE  destinations.sa_universities
SET     pop_high_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_universities.cell_id)
        ),
        pop_low_stress = (
            SELECT  SUM(cb.partial_p)
            FROM    generated.sa_pop_grid cb,
                    generated.sa_connected_pop_grid cbs
            WHERE   cbs.source_cellid = cb.cell_id
            AND     cbs.target_cellid = ANY(destinations.sa_universities.cell_id)
            AND     cbs.low_stress
        )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary as b
            WHERE   ST_Intersects(destinations.sa_universities.geom_pt,b.geometry)
        );

UPDATE  destinations.sa_universities
SET     pop_score = CASE    WHEN pop_high_stress IS NULL THEN NULL
                            WHEN pop_high_stress = 0 THEN 0
                            ELSE pop_low_stress::FLOAT / pop_high_stress
                            END;
SELECT * FROM generated.sa_pop_grid;                        
```

Once again, on this step I do not include the SQL codes, however they can be accessed through the `Rmd` file.

### 11. Compute overall access

During this step the overall access is computed for each population grid, meaning that we can already observe the BNA score spatial behavior within our study area. 

```{r, include = FALSE}
total = 100
people = 15
opportunity = 20
core_services = 20
retail = 15
recreation = 15
transit = 15
```

```{sql, connection = connection, output.var = "output", include = FALSE}
UPDATE  generated.sa_pop_grid
SET     overall_score = ?total *
            (
                ?people * COALESCE(pop_score,0)
                + ?opportunity *
                    CASE
                    WHEN    COALESCE(schools_high_stress,0)
                            + COALESCE(colleges_high_stress,0)
                            + COALESCE(universities_high_stress,0)
                            = 0 THEN 0
                    ELSE    (
                                (
                                    0.35 * COALESCE(emp_score,0)
                                    + 0.35 * COALESCE(schools_score,0)
                                    + 0.1 * COALESCE(colleges_score,0)
                                    + 0.2 * COALESCE(universities_score,0)
                                ) /
                                (
                                    0.35
                                    +   CASE
                                        WHEN schools_high_stress > 0
                                            THEN 0.35
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN colleges_high_stress > 0
                                            THEN 0.1
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN universities_high_stress > 0
                                            THEN 0.2
                                        ELSE 0
                                        END
                                )
                            )
                    END
                + ?core_services *
                    CASE
                    WHEN    COALESCE(doctors_high_stress,0)
                            + COALESCE(dentists_high_stress,0)
                            + COALESCE(hospitals_high_stress,0)
                            + COALESCE(pharmacies_high_stress,0)
                            + COALESCE(supermarkets_high_stress,0)
                            + COALESCE(social_services_high_stress,0)
                            = 0 THEN 0
                    ELSE    (
                                (
                                    0.2 * COALESCE(doctors_score,0)
                                    + 0.1 * COALESCE(dentists_score,0)
                                    + 0.2 * COALESCE(hospitals_score,0)
                                    + 0.1 * COALESCE(pharmacies_score,0)
                                    + 0.25 * COALESCE(supermarkets_score,0)
                                    + 0.15 * COALESCE(social_services_score,0)
                                ) /
                                (
                                    CASE
                                    WHEN doctors_high_stress > 0
                                        THEN 0.2
                                    ELSE 0
                                    END
                                    +   CASE
                                        WHEN dentists_high_stress > 0
                                            THEN 0.1
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN hospitals_high_stress > 0
                                            THEN 0.2
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN pharmacies_high_stress > 0
                                            THEN 0.1
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN supermarkets_high_stress > 0
                                            THEN 0.25
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN social_services_high_stress > 0
                                            THEN 0.15
                                        ELSE 0
                                        END
                                )
                            )
                    END
                + ?retail * COALESCE(retail_score,0)
                + ?recreation *
                    CASE
                    WHEN    COALESCE(parks_high_stress,0)
                            + COALESCE(trails_high_stress,0)
                            + COALESCE(community_centers_high_stress,0)
                            = 0 THEN 0
                    ELSE    (
                                (
                                    0.4 * COALESCE(parks_score,0)
                                    + 0.35 * COALESCE(trails_score,0)
                                    + 0.25 * COALESCE(community_centers_score,0)
                                ) /
                                (
                                    CASE
                                    WHEN parks_high_stress > 0
                                        THEN 0.4
                                    ELSE 0
                                    END
                                    +   CASE
                                        WHEN trails_high_stress > 0
                                            THEN 0.35
                                        ELSE 0
                                        END
                                    +   CASE
                                        WHEN community_centers_high_stress > 0
                                            THEN 0.25
                                        ELSE 0
                                        END
                                )
                            )
                    END
                + ?transit * COALESCE(transit_score,0)
            ) /
            (
                ?people
                +   CASE
                    WHEN COALESCE(schools_high_stress,0)
                            + COALESCE(colleges_high_stress,0)
                            + COALESCE(universities_high_stress,0)
                            = 0 THEN 0
                    ELSE ?opportunity
                    END
                +   CASE
                    WHEN COALESCE(doctors_high_stress,0)
                            + COALESCE(dentists_high_stress,0)
                            + COALESCE(hospitals_high_stress,0)
                            + COALESCE(pharmacies_high_stress,0)
                            + COALESCE(supermarkets_high_stress,0)
                            + COALESCE(social_services_high_stress,0)
                            = 0 THEN 0
                    ELSE ?core_services
                    END
                +   CASE
                    WHEN COALESCE(retail_high_stress,0) = 0 THEN 0
                    ELSE ?retail
                    END
                +   CASE
                    WHEN COALESCE(parks_high_stress,0)
                            + COALESCE(trails_high_stress,0)
                            + COALESCE(community_centers_high_stress,0)
                            = 0 THEN 0
                    ELSE ?recreation
                    END
                +   CASE
                    WHEN COALESCE(transit_high_stress,0) = 0
                        THEN 0
                    ELSE ?transit
                    END
            )
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(b.geometry,generated.sa_pop_grid.geometry)
        );
        
SELECT * FROM generated.sa_pop_grid;
```

### 12. Compute overall score for the whole study area

For this step a new table is generated in the database `sa_score_inputs` to store the preliminary results. The code can be accessed on the `Rmd` file. 

```{sql, connection = connection, include = FALSE}

DROP TABLE IF EXISTS generated.sa_score_inputs;

CREATE TABLE generated.sa_score_inputs (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score_name TEXT,
    score NUMERIC(16,4),
    notes TEXT,
    human_explanation TEXT,
    use_pop BOOLEAN,
    use_emp BOOLEAN,
    use_k12 BOOLEAN,
    use_tech BOOLEAN,
    use_univ BOOLEAN,
    use_doctor BOOLEAN,
    use_dentist BOOLEAN,
    use_hospital BOOLEAN,
    use_pharmacy BOOLEAN,
    use_retail BOOLEAN,
    use_grocery BOOLEAN,
    use_social_svcs BOOLEAN,
    use_parks BOOLEAN,
    use_trails BOOLEAN,
    use_comm_ctrs BOOLEAN,
    use_transit BOOLEAN
);

-------------------------------------
-- temporary table of total population
-- for weighting purposes
-------------------------------------
DROP TABLE IF EXISTS tmp_pop;
CREATE TEMP TABLE tmp_pop (
    overall INTEGER,
    k12 INTEGER,
    tech INTEGER,
    univ INTEGER,
    doctor INTEGER,
    dentist INTEGER,
    hospital INTEGER,
    pharmacy INTEGER,
    retail INTEGER,
    grocery INTEGER,
    social_svcs INTEGER,
    parks INTEGER,
    trails INTEGER,
    comm_ctrs INTEGER,
    transit INTEGER
);

INSERT INTO tmp_pop (
    overall, k12, tech, univ, doctor, dentist, hospital, pharmacy,
    retail, grocery, social_svcs, parks, trails, comm_ctrs, transit
)
SELECT  SUM(partial_p),
        SUM(CASE WHEN COALESCE(schools_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(colleges_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(universities_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(doctors_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(dentists_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(hospitals_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(pharmacies_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(retail_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(supermarkets_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(social_services_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(parks_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(trails_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(community_centers_high_stress,0) = 0 THEN 0 ELSE partial_p END),
        SUM(CASE WHEN COALESCE(transit_high_stress,0) = 0 THEN 0 ELSE partial_p END)
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );
SELECT * FROM generated.sa_score_inputs;

-------------------------------------
-- population
-------------------------------------
-- median pop access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'People',
        'Median score of access to population',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population accessible by low stress
            to population accessible overall, expressed as
            the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            half have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile pop access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'People',
        '70th percentile score of access to population',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
      regexp_replace('Score of population accessible by low stress
            to population accessible overall, expressed as
            the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            70% have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile pop access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'People',
        '30th percentile score of access to population',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population accessible by low stress
            to population accessible overall, expressed as
            the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            30% have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- avg pop access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'People',
        'Average score of access to population',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population accessible by low stress
            to population accessible overall, expressed as
            the average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            this ratio of low stress to high stress access.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_pop
)
SELECT  'People',
        'Average score of access to population',
        SUM(CASE WHEN tmp_pop.overall = 0 THEN 0 ELSE partial_p * pop_score / tmp_pop.overall END),
        regexp_replace('Average population score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this population score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );


-------------------------------------
-- employment
-------------------------------------
-- median jobs access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median score of access to employment',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN emp_high_stress=0 THEN 0 ELSE emp_low_stress::FLOAT/emp_high_stress END),
        regexp_replace('Score of employment accessible by low stress
            to employment accessible overall, expressed as
            the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            half have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile jobs access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile score of access to employment',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN emp_high_stress=0 THEN 0 ELSE emp_low_stress::FLOAT/emp_high_stress END),
        regexp_replace('Score of employment accessible by low stress
            to employment accessible overall, expressed as
            the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            70% have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile jobs access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile score of access to employment',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN emp_high_stress=0 THEN 0 ELSE emp_low_stress::FLOAT/emp_high_stress END),
        regexp_replace('Score of employment accessible by low stress
            to employment accessible overall, expressed as
            the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of all population grids in the study area have
            a ratio of low stress to high stress access above this number,
            30% have a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- avg jobs access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average score of access to employment',
        CASE    WHEN SUM(emp_high_stress) = 0 THEN 0
                ELSE SUM(emp_low_stress)::FLOAT / SUM(emp_high_stress)
                END,
        regexp_replace('Score of employment accessible by low stress
            to employment accessible overall, expressed as
            the average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            this ratio of low stress to high stress access.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_emp
)
SELECT  'Opportunity',
        'Average score of access to jobs',
        SUM(CASE WHEN tmp_pop.overall = 0 THEN 0 ELSE partial_p * emp_score / tmp_pop.overall END),
        regexp_replace('Average employment score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this employment score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-------------------------------------
-- schools
-------------------------------------
-- average school access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average score of low stress access to schools',
        CASE    WHEN SUM(schools_high_stress) = 0 THEN 0
                ELSE SUM(schools_low_stress) / SUM(schools_high_stress)
                END,
        regexp_replace('Number of schools accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many schools.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median schools access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median score of school access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN schools_high_stress=0 THEN 0 ELSE schools_low_stress::FLOAT/schools_high_stress END),
        regexp_replace('Score of schools accessible by low stress
            compared to schools accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of schools within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile schools access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile score of school access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN schools_high_stress=0 THEN 0 ELSE schools_low_stress::FLOAT/schools_high_stress END),
        regexp_replace('Score of schools accessible by low stress
            compared to schools accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of schools within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile schools access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile score of school access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN schools_high_stress=0 THEN 0 ELSE schools_low_stress::FLOAT/schools_high_stress END),
        regexp_replace('Score of schools accessible by low stress
            compared to schools accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of schools within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_k12
)
SELECT  'Opportunity',
        'Average score of access to K12 schools',
        SUM(CASE WHEN tmp_pop.k12 = 0 THEN 0 ELSE partial_p * schools_score / tmp_pop.k12 END),
        regexp_replace('Average K12 schools score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this K12 schools score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- school pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average school bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of schools in the study area expressed as an average of
            all schools in the study area','\n\s+',' ','g'),
        regexp_replace('On average, schools in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_schools
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_schools.geom_pt,b.geometry)
        );

-- school pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median school population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to schools
            in the study area to total population within the bike shed
            of each school expressed as a median of all
            schools in the study area','\n\s+',' ','g'),
        regexp_replace('Half of schools in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.','\n\s+',' ','g')
FROM    destinations.sa_schools
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_schools.geom_pt,b.geometry)
        );

-- school pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile school population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to schools
            in the study area to total population within the bike shed
            of each school expressed as the 70th percentile of all
            schools in the study area','\n\s+',' ','g'),
        regexp_replace('30% of schools in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.','\n\s+',' ','g')
FROM    destinations.sa_schools
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_schools.geom_pt,b.geometry)
        );

-- school pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile school population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to schools
            in the study area to total population within the bike shed
            of each school expressed as the 30th percentile of all
            schools in the study area','\n\s+',' ','g'),
        regexp_replace('70% of schools in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.','\n\s+',' ','g')
FROM    destinations.sa_schools
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_schools.geom_pt,b.geometry)
        );


-------------------------------------
-- technical/vocational colleges
-------------------------------------
-- average technical/vocational college access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average score of low stress access to tech/vocational colleges',
        CASE    WHEN SUM(colleges_high_stress) = 0 THEN 0
                ELSE SUM(colleges_low_stress) / SUM(colleges_high_stress)
                END,
        regexp_replace('Number of tech/vocational colleges accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many tech/vocational colleges.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median colleges access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median score of tech/vocational college access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN colleges_high_stress=0 THEN 0 ELSE colleges_low_stress::FLOAT/colleges_high_stress END),
        regexp_replace('Score of tech/vocational colleges accessible by low stress
            compared to tech/vocational colleges accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of tech/vocational colleges within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile colleges access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile score of tech/vocational college access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN colleges_high_stress=0 THEN 0 ELSE colleges_low_stress::FLOAT/colleges_high_stress END),
        regexp_replace('Score of tech/vocational colleges accessible by low stress
            compared to tech/vocational colleges accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of tech/vocational colleges within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile colleges access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile score of tech/vocational college access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN colleges_high_stress=0 THEN 0 ELSE colleges_low_stress::FLOAT/colleges_high_stress END),
        regexp_replace('Score of tech/vocational colleges accessible by low stress
            compared to tech/vocational colleges accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of tech/vocational colleges within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_tech
)
SELECT  'Opportunity',
        'Average score of access to tech/vocational colleges',
        SUM(CASE WHEN tmp_pop.tech = 0 THEN 0 ELSE partial_p * colleges_score / tmp_pop.tech END),
        regexp_replace('Average tech/vocational colleges score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this tech/vocational colleges score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- college pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average college bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of tech/vocational colleges in the study area expressed as an average of
            all colleges in the study area','\n\s+',' ','g'),
        regexp_replace('On average, colleges in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_colleges
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_colleges.geom_pt,b.geometry)
        );

-- college pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median tech/vocational college population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to tech/vocational colleges
            in the study area to total population within the bike shed
            of each college expressed as a median of all
            colleges in the study area','\n\s+',' ','g'),
        regexp_replace('Half of tech/vocational colleges in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one tech/vocational college exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_colleges
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_colleges.geom_pt,b.geometry)
        );

-- college pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile tech/vocational college population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to tech/vocational colleges
            in the study area to total population within the bike shed
            of each college expressed as the 70th percentile of all
            colleges in the study area','\n\s+',' ','g'),
        regexp_replace('30% of tech/vocational colleges in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one tech/vocational college exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_colleges
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_colleges.geom_pt,b.geometry)
        );

-- college pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile tech/vocational college population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to tech/vocational colleges
            in the study area to total population within the bike shed
            of each college expressed as the 30th percentile of all
            colleges in the study area','\n\s+',' ','g'),
        regexp_replace('70% of tech/vocational colleges in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one tech/vocational college exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_colleges
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_colleges.geom_pt,b.geometry)
        );


-------------------------------------
-- universities
-------------------------------------
-- average university access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average score of low stress access to universities',
        CASE    WHEN SUM(universities_high_stress) = 0 THEN 0
                ELSE SUM(universities_low_stress) / SUM(universities_high_stress)
                END,
        regexp_replace('Number of universities accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many universities.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median universities access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median score of university access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN universities_high_stress=0 THEN 0 ELSE universities_low_stress::FLOAT/universities_high_stress END),
        regexp_replace('Score of universities accessible by low stress
            compared to universities accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of universities within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile universities access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile score of university access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN universities_high_stress=0 THEN 0 ELSE universities_low_stress::FLOAT/universities_high_stress END),
        regexp_replace('Score of universities accessible by low stress
            compared to universities accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of universities within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile universities access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile score of university access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN universities_high_stress=0 THEN 0 ELSE universities_low_stress::FLOAT/universities_high_stress END),
        regexp_replace('Score of universities accessible by low stress
            compared to universities accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of universities within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_univ
)
SELECT  'Opportunity',
        'Average score of access to universities',
        SUM(CASE WHEN tmp_pop.univ = 0 THEN 0 ELSE partial_p * universities_score / tmp_pop.univ END),
        regexp_replace('Average universities score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this universities score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- university pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Average university bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of universities in the study area expressed as an average of
            all universities in the study area','\n\s+',' ','g'),
        regexp_replace('On average, universities in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_universities
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_universities.geom_pt,b.geometry)
        );

-- university pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        'Median university population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to universities
            in the study area to total population within the bike shed
            of each university expressed as a median of all
            universities in the study area','\n\s+',' ','g'),
        regexp_replace('Half of universities in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one university exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_universities
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_universities.geom_pt,b.geometry)
        );

-- university pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '70th percentile university population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to universities
            in the study area to total population within the bike shed
            of each university expressed as the 70th percentile of all
            universities in the study area','\n\s+',' ','g'),
        regexp_replace('30% of universities in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one university exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_universities
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_universities.geom_pt,b.geometry)
        );

-- university pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Opportunity',
        '30th percentile university population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to universities
            in the study area to total population within the bike shed
            of each university expressed as the 30th percentile of all
            universities in the study area','\n\s+',' ','g'),
        regexp_replace('70% of universities in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one university exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_universities
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_universities.geom_pt,b.geometry)
        );


-------------------------------------
-- doctors
-------------------------------------
-- average doctors access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to doctors',
        CASE    WHEN SUM(doctors_high_stress) = 0 THEN 0
                ELSE SUM(doctors_low_stress) / SUM(doctors_high_stress)
                END,
        regexp_replace('Number of doctors accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many doctors.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median doctors access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of doctors access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN doctors_high_stress=0 THEN 0 ELSE doctors_low_stress::FLOAT/doctors_high_stress END),
        regexp_replace('Score of doctors accessible by low stress
            compared to doctors accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of doctors within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile doctors access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of doctors access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN doctors_high_stress=0 THEN 0 ELSE doctors_low_stress::FLOAT/doctors_high_stress END),
        regexp_replace('Score of doctors accessible by low stress
            compared to doctors accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of doctors within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile doctors access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of doctors access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN doctors_high_stress=0 THEN 0 ELSE doctors_low_stress::FLOAT/doctors_high_stress END),
        regexp_replace('Score of doctors accessible by low stress
            compared to doctors accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of doctors within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_doctor
)
SELECT  'Core Services',
        'Average score of access to doctors',
        SUM(CASE WHEN tmp_pop.doctor = 0 THEN 0 ELSE partial_p * doctors_score / tmp_pop.doctor END),
        regexp_replace('Average doctors score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this doctors score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- doctors pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average doctors bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of doctors in the study area expressed as an average of
            all doctors in the study area','\n\s+',' ','g'),
        regexp_replace('On average, doctors in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_doctors
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_doctors.geom_pt,b.geometry)
        );

-- doctors pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median doctors population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to doctors
            in the study area to total population within the bike shed
            of each doctors office expressed as a median of all
            doctors in the study area','\n\s+',' ','g'),
        regexp_replace('Half of doctors in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one doctors office exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_doctors
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_doctors.geom_pt,b.geometry)
        );

-- doctors pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile doctors population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to doctors
            in the study area to total population within the bike shed
            of each doctors office expressed as the 70th percentile of all
            doctors in the study area','\n\s+',' ','g'),
        regexp_replace('30% of doctors in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one doctors exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_doctors
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_doctors.geom_pt,b.geometry)
        );

-- doctors pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile doctors population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to doctors
            in the study area to total population within the bike shed
            of each doctors office expressed as the 30th percentile of all
            doctors in the study area','\n\s+',' ','g'),
        regexp_replace('70% of doctors in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one doctors exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_doctors
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_doctors.geom_pt,b.geometry)
        );

-------------------------------------
-- dentists
-------------------------------------
-- average dentists access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to dentists',
        CASE    WHEN SUM(dentists_high_stress) = 0 THEN 0
                ELSE SUM(dentists_low_stress) / SUM(dentists_high_stress)
                END,
        regexp_replace('Number of dentists accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many dentists.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median dentists access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of dentists access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN dentists_high_stress=0 THEN 0 ELSE dentists_low_stress::FLOAT/dentists_high_stress END),
        regexp_replace('Score of dentists accessible by low stress
            compared to dentists accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of dentists within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile dentists access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of dentists access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN dentists_high_stress=0 THEN 0 ELSE dentists_low_stress::FLOAT/dentists_high_stress END),
        regexp_replace('Score of dentists accessible by low stress
            compared to dentists accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of dentists within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile dentists access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of dentists access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN dentists_high_stress=0 THEN 0 ELSE dentists_low_stress::FLOAT/dentists_high_stress END),
        regexp_replace('Score of dentists accessible by low stress
            compared to dentists accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of dentists within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_dentist
)
SELECT  'Core Services',
        'Average score of access to dentists',
        SUM(CASE WHEN tmp_pop.dentist = 0 THEN 0 ELSE partial_p * dentists_score / tmp_pop.dentist END),
        regexp_replace('Average dentists score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this dentists score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- dentists pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average dentists bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of dentists in the study area expressed as an average of
            all dentists in the study area','\n\s+',' ','g'),
        regexp_replace('On average, dentists in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_dentists
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_dentists.geom_pt,b.geometry)
        );

-- dentists pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median dentists population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to dentists
            in the study area to total population within the bike shed
            of each dentists office expressed as a median of all
            dentists in the study area','\n\s+',' ','g'),
        regexp_replace('Half of dentists in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one dentists office exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_dentists
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_dentists.geom_pt,b.geometry)
        );

-- dentists pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile dentists population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to dentists
            in the study area to total population within the bike shed
            of each dentists office expressed as the 70th percentile of all
            dentists in the study area','\n\s+',' ','g'),
        regexp_replace('30% of dentists in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one dentists office exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_dentists
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_dentists.geom_pt,b.geometry)
        );

-- dentists pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile dentists population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to dentists
            in the study area to total population within the bike shed
            of each dentists office expressed as the 30th percentile of all
            dentists in the study area','\n\s+',' ','g'),
        regexp_replace('70% of dentists in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one dentists office exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_dentists
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_dentists.geom_pt,b.geometry)
        );

-------------------------------------
-- hospitals
-------------------------------------
-- average hospitals access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to hospitals',
        CASE    WHEN SUM(hospitals_high_stress) = 0 THEN 0
                ELSE SUM(hospitals_low_stress) / SUM(hospitals_high_stress)
                END,
        regexp_replace('Number of hospitals accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many hospitals.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median hospitals access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of hospitals access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN hospitals_high_stress=0 THEN 0 ELSE hospitals_low_stress::FLOAT/hospitals_high_stress END),
        regexp_replace('Score of hospitals accessible by low stress
            compared to hospitals accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of hospitals within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile hospitals access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of hospitals access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN hospitals_high_stress=0 THEN 0 ELSE hospitals_low_stress::FLOAT/hospitals_high_stress END),
        regexp_replace('Score of hospitals accessible by low stress
            compared to hospitals accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of hospitals within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile hospitals access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of hospitals access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN hospitals_high_stress=0 THEN 0 ELSE hospitals_low_stress::FLOAT/hospitals_high_stress END),
        regexp_replace('Score of hospitals accessible by low stress
            compared to hospitals accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of hospitals within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_hospital
)
SELECT  'Core Services',
        'Average score of access to hospitals',
        SUM(CASE WHEN tmp_pop.hospital = 0 THEN 0 ELSE partial_p * hospitals_score / tmp_pop.hospital END),
        regexp_replace('Average hospital score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this hospital score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- hospitals pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average hospitals bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of hospitals in the study area expressed as an average of
            all hospitals in the study area','\n\s+',' ','g'),
        regexp_replace('On average, hospitals in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_hospitals
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_pt,b.geometry)
        );

-- hospitals pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median hospitals population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to hospitals
            in the study area to total population within the bike shed
            of each hospital expressed as a median of all
            hospitals in the study area','\n\s+',' ','g'),
        regexp_replace('Half of hospitals in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one hospital exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_hospitals
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_pt,b.geometry)
        );

-- hospitals pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile hospitals population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to hospitals
            in the study area to total population within the bike shed
            of each hospital expressed as the 70th percentile of all
            hospitals in the study area','\n\s+',' ','g'),
        regexp_replace('30% of hospitals in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one hospital exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_hospitals
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_pt,b.geometry)
        );

-- hospitals pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile hospitals population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to hospitals
            in the study area to total population within the bike shed
            of each hospital expressed as the 30th percentile of all
            hospitals in the study area','\n\s+',' ','g'),
        regexp_replace('70% of hospitals in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one hospital exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_hospitals
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_hospitals.geom_pt,b.geometry)
        );

-------------------------------------
-- pharmacies
-------------------------------------
-- average pharmacies access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to pharmacies',
        CASE    WHEN SUM(pharmacies_high_stress) = 0 THEN 0
                ELSE SUM(pharmacies_low_stress) / SUM(pharmacies_high_stress)
                END,
        regexp_replace('Number of pharmacies accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many pharmacies.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median pharmacies access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of pharmacies access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pharmacies_high_stress=0 THEN 0 ELSE pharmacies_low_stress::FLOAT/pharmacies_high_stress END),
        regexp_replace('Score of pharmacies accessible by low stress
            compared to pharmacies accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of pharmacies within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile pharmacies access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of pharmacies access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pharmacies_high_stress=0 THEN 0 ELSE pharmacies_low_stress::FLOAT/pharmacies_high_stress END),
        regexp_replace('Score of pharmacies accessible by low stress
            compared to pharmacies accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of pharmacies within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile pharmacies access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of pharmacies access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pharmacies_high_stress=0 THEN 0 ELSE pharmacies_low_stress::FLOAT/pharmacies_high_stress END),
        regexp_replace('Score of pharmacies accessible by low stress
            compared to pharmacies accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of pharmacies within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_pharmacy
)
SELECT  'Core Services',
        'Average score of access to pharmacies',
        SUM(CASE WHEN tmp_pop.pharmacy = 0 THEN 0 ELSE partial_p * pharmacies_score / tmp_pop.pharmacy END),
        regexp_replace('Average pharmacies score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this pharmacies score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- pharmacies pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average pharmacies bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of pharmacies in the study area expressed as an average of
            all pharmacies in the study area','\n\s+',' ','g'),
        regexp_replace('On average, pharmacies in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_pharmacies
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_pt,b.geometry)
        );

-- pharmacies pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median pharmacies population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to pharmacies
            in the study area to total population within the bike shed
            of each pharmacy expressed as a median of all
            pharmacies in the study area','\n\s+',' ','g'),
        regexp_replace('Half of pharmacies in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one pharmacy exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_pharmacies
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_pt,b.geometry)
        );

-- pharmacies pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile pharmacies population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to pharmacies
            in the study area to total population within the bike shed
            of each pharmacy expressed as the 70th percentile of all
            pharmacies in the study area','\n\s+',' ','g'),
        regexp_replace('30% of pharmacies in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one pharmacy exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_pharmacies
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_pt,b.geometry)
        );

-- pharmacies pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile pharmacies population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to pharmacies
            in the study area to total population within the bike shed
            of each pharmacy expressed as the 30th percentile of all
            pharmacies in the study area','\n\s+',' ','g'),
        regexp_replace('70% of pharmacies in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one pharmacy exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_pharmacies
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_pharmacies.geom_pt,b.geometry)
        );

-------------------------------------
-- retail
-------------------------------------
-- average retail access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        'Average score of low stress access to retail',
        CASE    WHEN SUM(retail_high_stress) = 0 THEN 0
                ELSE SUM(retail_low_stress) / SUM(retail_high_stress)
                END,
        regexp_replace('Number of retail accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many retail.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median retail access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        'Median score of retail access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN retail_high_stress=0 THEN 0 ELSE retail_low_stress::FLOAT/retail_high_stress END),
        regexp_replace('Score of retail accessible by low stress
            compared to retail accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of retail within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile retail access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        '70th percentile score of retail access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN retail_high_stress=0 THEN 0 ELSE retail_low_stress::FLOAT/retail_high_stress END),
        regexp_replace('Score of retail accessible by low stress
            compared to retail accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of retail within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile retail access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        '30th percentile score of retail access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN retail_high_stress=0 THEN 0 ELSE retail_low_stress::FLOAT/retail_high_stress END),
        regexp_replace('Score of retail accessible by low stress
            compared to retail accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of retail within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_retail
)
SELECT  'Retail',
        'Average score of access to retail',
        SUM(CASE WHEN tmp_pop.retail = 0 THEN 0 ELSE partial_p * retail_score / tmp_pop.retail END),
        regexp_replace('Average retail score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this retail score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- retail pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        'Average retail bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of retail clusters in the study area expressed as an average of
            all retail clusters in the study area','\n\s+',' ','g'),
        regexp_replace('On average, retail clusters in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_retail
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,b.geometry)
        );

-- retail pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        'Median retail population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to retail
            in the study area to total population within the bike shed
            of each retail cluster expressed as a median of all
            retail clusters in the study area','\n\s+',' ','g'),
        regexp_replace('Half of retail clusters in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one retail exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_retail
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,b.geometry)
        );

-- retail pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        '70th percentile retail population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to retail
            in the study area to total population within the bike shed
            of each retail cluster expressed as the 70th percentile of all
            retail clusters in the study area','\n\s+',' ','g'),
        regexp_replace('30% of retail clusters in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one retail exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_retail
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,b.geometry)
        );

-- retail pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Retail',
        '30th percentile retail population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to retail
            in the study area to total population within the bike shed
            of each retail cluster expressed as the 30th percentile of all
            retail clusters in the study area','\n\s+',' ','g'),
        regexp_replace('70% of retail clusters in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one retail exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_retail
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_retail.geom_poly,b.geometry)
        );

-------------------------------------
-- supermarkets
-------------------------------------
-- average supermarkets access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to supermarkets',
        CASE    WHEN SUM(supermarkets_high_stress) = 0 THEN 0
                ELSE SUM(supermarkets_low_stress) / SUM(supermarkets_high_stress)
                END,
        regexp_replace('Number of supermarkets accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many supermarkets.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median supermarkets access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of supermarkets access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN supermarkets_high_stress=0 THEN 0 ELSE supermarkets_low_stress::FLOAT/supermarkets_high_stress END),
        regexp_replace('Score of supermarkets accessible by low stress
            compared to supermarkets accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of supermarkets within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile supermarkets access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of supermarkets access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN supermarkets_high_stress=0 THEN 0 ELSE supermarkets_low_stress::FLOAT/supermarkets_high_stress END),
        regexp_replace('Score of supermarkets accessible by low stress
            compared to supermarkets accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of supermarkets within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile supermarkets access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of supermarkets access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN supermarkets_high_stress=0 THEN 0 ELSE supermarkets_low_stress::FLOAT/supermarkets_high_stress END),
        regexp_replace('Score of supermarkets accessible by low stress
            compared to supermarkets accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of supermarkets within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_grocery
)
SELECT  'Core Services',
        'Average score of access to grocery stores',
        SUM(CASE WHEN tmp_pop.grocery = 0 THEN 0 ELSE partial_p * supermarkets_score / tmp_pop.grocery END),
        regexp_replace('Average grocery score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this grocery score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- supermarkets pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average supermarkets bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of supermarkets in the study area expressed as an average of
            all supermarkets in the study area','\n\s+',' ','g'),
        regexp_replace('On average, supermarkets in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_supermarkets
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_pt,b.geometry)
        );

-- supermarkets pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median supermarkets population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to supermarkets
            in the study area to total population within the bike shed
            of each supermarket expressed as a median of all
            supermarkets in the study area','\n\s+',' ','g'),
        regexp_replace('Half of supermarkets in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one supermarkets exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_supermarkets
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_pt,b.geometry)
        );

-- supermarkets pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile supermarkets population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to supermarkets
            in the study area to total population within the bike shed
            of each supermarket expressed as the 70th percentile of all
            supermarkets in the study area','\n\s+',' ','g'),
        regexp_replace('30% of supermarkets in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one supermarkets exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_supermarkets
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_pt,b.geometry)
        );

-- supermarkets pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile supermarkets population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to supermarkets
            in the study area to total population within the bike shed
            of each supermarket expressed as the 30th percentile of all
            supermarkets in the study area','\n\s+',' ','g'),
        regexp_replace('70% of supermarkets in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one supermarkets exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_supermarkets
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_supermarkets.geom_pt,b.geometry)
        );

-------------------------------------
-- social_services
-------------------------------------
-- average social_services access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average score of low stress access to social services',
        CASE    WHEN SUM(social_services_high_stress) = 0 THEN 0
                ELSE SUM(social_services_low_stress) / SUM(social_services_high_stress)
                END,
        regexp_replace('Number of social services accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many social services.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median social_services access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median score of social services access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN social_services_high_stress=0 THEN 0 ELSE social_services_low_stress::FLOAT/social_services_high_stress END),
        regexp_replace('Score of social services accessible by low stress
            compared to social services accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of social services within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile social_services access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile score of social services access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN social_services_high_stress=0 THEN 0 ELSE social_services_low_stress::FLOAT/social_services_high_stress END),
        regexp_replace('Score of social services accessible by low stress
            compared to social services accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of social services within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile social_services access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile score of social services access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN social_services_high_stress=0 THEN 0 ELSE social_services_low_stress::FLOAT/social_services_high_stress END),
        regexp_replace('Score of social services accessible by low stress
            compared to social services accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of social services within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_social_svcs
)
SELECT  'Core Services',
        'Average score of access to social services',
        SUM(CASE WHEN tmp_pop.social_svcs = 0 THEN 0 ELSE partial_p * social_services_score / tmp_pop.social_svcs END),
        regexp_replace('Average social services score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this social services score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- social_services pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Average social_services bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of social services in the study area expressed as an average of
            all social services in the study area','\n\s+',' ','g'),
        regexp_replace('On average, social_services in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_social_services
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_social_services.geom_pt,b.geometry)
        );

-- social_services pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        'Median social_services population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to social services
            in the study area to total population within the bike shed
            of each social service location expressed as a median of all
            social services in the study area','\n\s+',' ','g'),
        regexp_replace('Half of social services in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one social_services exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_social_services
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_social_services.geom_pt,b.geometry)
        );

-- social_services pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '70th percentile social_services population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to social services
            in the study area to total population within the bike shed
            of each social service location expressed as the 70th percentile of all
            social services in the study area','\n\s+',' ','g'),
        regexp_replace('30% of social services in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one social_services exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_social_services
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_social_services.geom_pt,b.geometry)
        );

-- social_services pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Core Services',
        '30th percentile social_services population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to social services
            in the study area to total population within the bike shed
            of each social service location expressed as the 30th percentile of all
            social services in the study area','\n\s+',' ','g'),
        regexp_replace('70% of social services in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one social_services exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_social_services
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_social_services.geom_pt,b.geometry)
        );

-------------------------------------
-- parks
-------------------------------------
-- average parks access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Average score of low stress access to parks',
        CASE    WHEN SUM(parks_high_stress) = 0 THEN 0
                ELSE SUM(parks_low_stress) / SUM(parks_high_stress)
                END,
        regexp_replace('Number of parks accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many parks.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median parks access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Median score of parks access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN parks_high_stress=0 THEN 0 ELSE parks_low_stress::FLOAT/parks_high_stress END),
        regexp_replace('Score of parks accessible by low stress
            compared to parks accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of parks within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile parks access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '70th percentile score of parks access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN parks_high_stress=0 THEN 0 ELSE parks_low_stress::FLOAT/parks_high_stress END),
        regexp_replace('Score of parks accessible by low stress
            compared to parks accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of parks within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile parks access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '30th percentile score of parks access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN parks_high_stress=0 THEN 0 ELSE parks_low_stress::FLOAT/parks_high_stress END),
        regexp_replace('Score of parks accessible by low stress
            compared to parks accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of parks within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_parks
)
SELECT  'Recreation',
        'Average score of access to parks',
        SUM(CASE WHEN tmp_pop.parks = 0 THEN 0 ELSE partial_p * parks_score / tmp_pop.parks END),
        regexp_replace('Average parks score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this parks score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- parks pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Average parks bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of parks in the study area expressed as an average of
            all parks in the study area','\n\s+',' ','g'),
        regexp_replace('On average, parks in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_parks
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_parks.geom_pt,b.geometry)
        );

-- parks pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Median parks population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to parks
            in the study area to total population within the bike shed
            of each parks expressed as a median of all
            parks in the study area','\n\s+',' ','g'),
        regexp_replace('Half of parks in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one parks exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_parks
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_parks.geom_pt,b.geometry)
        );

-- parks pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '70th percentile parks population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to parks
            in the study area to total population within the bike shed
            of each parks expressed as the 70th percentile of all
            parks in the study area','\n\s+',' ','g'),
        regexp_replace('30% of parks in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one parks exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_parks
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_parks.geom_pt,b.geometry)
        );

-- parks pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '30th percentile parks population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to parks
            in the study area to total population within the bike shed
            of each parks expressed as the 30th percentile of all
            parks in the study area','\n\s+',' ','g'),
        regexp_replace('70% of parks in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one parks exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_parks
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_parks.geom_pt,b.geometry)
        );

-------------------------------------
-- trails
-------------------------------------
-- average trails access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Average score of low stress access to trails',
        CASE    WHEN SUM(trails_high_stress) = 0 THEN 0
                ELSE SUM(trails_low_stress) / SUM(trails_high_stress)
                END,
        regexp_replace('Number of trails accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many trails.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median trails access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Median score of trails access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN trails_high_stress=0 THEN 0 ELSE trails_low_stress::FLOAT/trails_high_stress END),
        regexp_replace('Score of trails accessible by low stress
            compared to trails accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of trails within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile trails access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '70th percentile score of trails access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN trails_high_stress=0 THEN 0 ELSE trails_low_stress::FLOAT/trails_high_stress END),
        regexp_replace('Score of trails accessible by low stress
            compared to trails accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of trails within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile trails access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '30th percentile score of trails access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN trails_high_stress=0 THEN 0 ELSE trails_low_stress::FLOAT/trails_high_stress END),
        regexp_replace('Score of trails accessible by low stress
            compared to trails accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of trails within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_trails
)
SELECT  'Recreation',
        'Average score of access to trails',
        SUM(CASE WHEN tmp_pop.trails = 0 THEN 0 ELSE partial_p * trails_score / tmp_pop.trails END),
        regexp_replace('Average trails score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this trails score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );
-------------------------------------
-- community_centers
-------------------------------------
-- average community_centers access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Average score of low stress access to community centers',
        CASE    WHEN SUM(community_centers_high_stress) = 0 THEN 0
                ELSE SUM(community_centers_low_stress) / SUM(community_centers_high_stress)
                END,
        regexp_replace('Number of community centers accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many community centers.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median community centers access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Median score of community centers access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN community_centers_high_stress=0 THEN 0 ELSE community_centers_low_stress::FLOAT/community_centers_high_stress END),
        regexp_replace('Score of community centers accessible by low stress
            compared to community centers accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of community centers within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile community centers access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '70th percentile score of community centers access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN community_centers_high_stress=0 THEN 0 ELSE community_centers_low_stress::FLOAT/community_centers_high_stress END),
        regexp_replace('Score of community centers accessible by low stress
            compared to community centers accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of community centers within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile community centers access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '30th percentile score of community centers access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN community_centers_high_stress=0 THEN 0 ELSE community_centers_low_stress::FLOAT/community_centers_high_stress END),
        regexp_replace('Score of community centers accessible by low stress
            compared to community centers accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of community centers within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_comm_ctrs
)
SELECT  'Recreation',
        'Average score of access to community centers',
        SUM(CASE WHEN tmp_pop.comm_ctrs = 0 THEN 0 ELSE partial_p * community_centers_score / tmp_pop.comm_ctrs END),
        regexp_replace('Average community centers score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this community centers score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- community centers pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Average community centers bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of community centers in the study area expressed as an average of
            all community centers in the study area','\n\s+',' ','g'),
        regexp_replace('On average, community centers in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_community_centers
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_pt,b.geometry)
        );

-- community centers pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        'Median community centers population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to community centers
            in the study area to total population within the bike shed
            of each community centers expressed as a median of all
            community centers in the study area','\n\s+',' ','g'),
        regexp_replace('Half of community centers in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one community centers exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_community_centers
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_pt,b.geometry)
        );

-- community centers pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '70th percentile community centers population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to community centers
            in the study area to total population within the bike shed
            of each community centers expressed as the 70th percentile of all
            community centers in the study area','\n\s+',' ','g'),
        regexp_replace('30% of community centers in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one community centers exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_community_centers
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_pt,b.geometry)
        );

-- community centers pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Recreation',
        '30th percentile community centers population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to community centers
            in the study area to total population within the bike shed
            of each community centers expressed as the 30th percentile of all
            community centers in the study area','\n\s+',' ','g'),
        regexp_replace('70% of community centers in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one community centers exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_community_centers
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_community_centers.geom_pt,b.geometry)
        );

-------------------------------------
-- transit
-------------------------------------
-- average transit access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        'Average score of low stress access to transit',
        CASE    WHEN SUM(transit_high_stress) = 0 THEN 0
                ELSE SUM(transit_low_stress) / SUM(transit_high_stress)
                END,
        regexp_replace('Number of transit stations accessible by low stress
            expressed as an average of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area have
            low stress access to this many transit stations.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- median transit access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        'Median score of transit access',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN transit_high_stress=0 THEN 0 ELSE transit_low_stress::FLOAT/transit_high_stress END),
        regexp_replace('Score of transit stations accessible by low stress
            compared to transit stations accessible by high stress
            expressed as the median of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('Half of population grids in this study area
            have low stress access to a higher ratio of transit stations within
            biking distance, half have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 70th percentile transit access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        '70th percentile score of transit access',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN transit_high_stress=0 THEN 0 ELSE transit_low_stress::FLOAT/transit_high_stress END),
        regexp_replace('Score of transit stations accessible by low stress
            compared to transit stations accessible by high stress
            expressed as the 70th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('30% of population grids in this study area
            have low stress access to a higher ratio of transit stations within
            biking distance, 70% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- 30th percentile transit access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        '30th percentile score of transit access',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN transit_high_stress=0 THEN 0 ELSE transit_low_stress::FLOAT/transit_high_stress END),
        regexp_replace('Score of transit stations accessible by low stress
            compared to transit stations accessible by high stress
            expressed as the 30th percentile of all population grids in the
            study area','\n\s+',' ','g'),
        regexp_replace('70% of population grids in this study area
            have low stress access to a higher ratio of transit stations within
            biking distance, 30% have access to a lower ratio.','\n\s+',' ','g')
FROM    generated.sa_pop_grid
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- population weighted census block score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation, use_transit
)
SELECT  'Transit',
        'Average score of access to transit',
        SUM(CASE WHEN tmp_pop.transit = 0 THEN 0 ELSE partial_p * transit_score / tmp_pop.transit END),
        regexp_replace('Average transit score for population grids
            weighted by population.','\n\s+',' ','g'),
        regexp_replace('On average, population grids in the study area received
            this transit score.','\n\s+',' ','g'),
        True
FROM    generated.sa_pop_grid,
        tmp_pop
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(generated.sa_pop_grid.geometry,b.geometry)
        );

-- transit pop shed average low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        'Average transit bike shed access score',
        CASE    WHEN SUM(pop_high_stress) = 0 THEN 0
                ELSE SUM(pop_low_stress)::FLOAT / SUM(pop_high_stress)
                END,
        regexp_replace('Score of population with low stress access
            compared to total population within the bike shed distance
            of transit stations in the study area expressed as an average of
            all transit stations in the study area','\n\s+',' ','g'),
        regexp_replace('On average, transit stations in the study area are
            connected by the low stress access to this percentage people
            within biking distance.','\n\s+',' ','g')
FROM    destinations.sa_transit
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_transit.geom_pt,b.geometry)
        );

-- transit pop shed median low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        'Median transit population shed score',
        percentile_disc(0.5) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to transit stations
            in the study area to total population within the bike shed
            of each transit stations expressed as a median of all
            transit stations in the study area','\n\s+',' ','g'),
        regexp_replace('Half of transit stations in the study area have low stress
            connections to a higher percentage of people within biking
            distance, half are connected to a lower percentage.
            (if only one transit station exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_transit
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_transit.geom_pt,b.geometry)
        );

-- transit pop shed 70th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        '70th percentile transit population shed score',
        percentile_disc(0.7) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to transit stations
            in the study area to total population within the bike shed
            of each transit stations expressed as the 70th percentile of all
            transit stations in the study area','\n\s+',' ','g'),
        regexp_replace('30% of transit stations in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 70% are connected to a lower percentage.
            (if only one transit station exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_transit
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_transit.geom_pt,b.geometry)
        );

-- transit pop shed 30th percentile low stress access score
INSERT INTO generated.sa_score_inputs (
    category, score_name, score, notes, human_explanation
)
SELECT  'Transit',
        '30th percentile transit population shed score',
        percentile_disc(0.3) WITHIN GROUP(ORDER BY CASE WHEN pop_high_stress=0 THEN 0 ELSE pop_low_stress::FLOAT/pop_high_stress END),
        regexp_replace('Score of population with low stress access to transit stations
            in the study area to total population within the bike shed
            of each transit stations expressed as the 30th percentile of all
            transit stations in the study area','\n\s+',' ','g'),
        regexp_replace('70% of transit stations in the study area have low stress
            connections to a higher percentage of people within biking
            distance, 30% are connected to a lower percentage.
            (if only one transit station exists this is the score for that one
            location)','\n\s+',' ','g')
FROM    destinations.sa_transit
WHERE   EXISTS (
            SELECT  1
            FROM    received.sa_boundary AS b
            WHERE   ST_Intersects(destinations.sa_transit.geom_pt,b.geometry)
        );

SELECT * FROM generated.sa_score_inputs;
```

```{sql, connection = connection, include = FALSE, output.var = "bna_score_table"}

DROP TABLE IF EXISTS generated.sa_overall_scores;

CREATE TABLE generated.sa_overall_scores (
    id SERIAL PRIMARY KEY,
    score_id TEXT,
    score_original NUMERIC(16,4),
    score_normalized NUMERIC(16,4),
    human_explanation TEXT
);

-- population
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'people',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_pop;

-- employment
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'opportunity_employment',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_emp;

-- k12 education
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'opportunity_k12_education',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_k12;

-- tech school
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'opportunity_technical_vocational_college',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_tech;

-- higher ed
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'opportunity_higher_education',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_univ;

-- opportunity
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'opportunity',
        (
            0.35 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'opportunity_employment')
            + 0.35 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'opportunity_k12_education')
            + 0.1 * (select score_original from generated.sa_overall_scores where score_id = 'opportunity_technical_vocational_college')
            + 0.2 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'opportunity_higher_education')
        ) /
        (
            0.35
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE schools_high_stress > 0)
                    THEN 0.35
                ELSE 0
                END
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE colleges_high_stress > 0)
                    THEN 0.1
                ELSE 0
                END
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE universities_high_stress > 0)
                    THEN 0.2
                ELSE 0
                END
        ),
        NULL;

-- doctors
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_doctors',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_doctor;

-- dentists
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_dentists',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_dentist;

-- hospitals
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_hospitals',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_hospital;

-- pharmacies
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_pharmacies',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_pharmacy;

-- grocery
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_grocery',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_grocery;

-- social services
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services_social_services',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_social_svcs;

-- core services
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'core_services',
        CASE
        WHEN EXISTS (
            SELECT  1
            FROM    generated.sa_pop_grid
            WHERE   doctors_high_stress > 0
            OR      dentists_high_stress > 0
            OR      hospitals_high_stress > 0
            OR      pharmacies_high_stress > 0
            OR      supermarkets_high_stress > 0
            OR      social_services_high_stress > 0
        )
            THEN    (
                        0.2 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_doctors')
                        + 0.1 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_dentists')
                        + 0.2 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_hospitals')
                        + 0.1 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_pharmacies')
                        + 0.25 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_grocery')
                        + 0.15 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services_social_services')
                    ) /
                    (
                        CASE
                        WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE doctors_high_stress > 0)
                            THEN 0.2
                        ELSE 0
                        END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE dentists_high_stress > 0)
                                THEN 0.1
                            ELSE 0
                            END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE hospitals_high_stress > 0)
                                THEN 0.2
                            ELSE 0
                            END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE pharmacies_high_stress > 0)
                                THEN 0.1
                            ELSE 0
                            END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE supermarkets_high_stress > 0)
                                THEN 0.25
                            ELSE 0
                            END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE social_services_high_stress > 0)
                                THEN 0.15
                            ELSE 0
                            END
                    )
        ELSE NULL
        END,
        NULL;

-- retail
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'retail',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_retail;

-- parks
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'recreation_parks',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_parks;

-- trails
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'recreation_trails',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_trails;

-- community_centers
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'recreation_community_centers',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_comm_ctrs;

-- recreation
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'recreation',
        CASE
        WHEN EXISTS (
            SELECT  1
            FROM    generated.sa_pop_grid
            WHERE   parks_high_stress > 0
            OR      trails_high_stress > 0
            OR      community_centers_high_stress > 0
        )
            THEN    (
                        0.4 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'recreation_parks')
                        + 0.35 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'recreation_trails')
                        + 0.25 * (SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'recreation_community_centers')
                    ) /
                    (
                        CASE
                        WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE parks_high_stress > 0)
                            THEN 0.4
                        ELSE 0
                        END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE trails_high_stress > 0)
                                THEN 0.35
                            ELSE 0
                            END
                        +   CASE
                            WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE community_centers_high_stress > 0)
                                THEN 0.25
                            ELSE 0
                            END
                    )
        ELSE NULL
        END,
        NULL;

-- transit
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'transit',
        COALESCE(generated.sa_score_inputs.score,0),
        generated.sa_score_inputs.human_explanation
FROM    generated.sa_score_inputs
WHERE   use_transit;

-- calculate overall neighborhood score
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'overall_score',
        (
            ?people * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'people'),0)
            + ?opportunity * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'opportunity'),0)
            + ?core_services * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'core_services'),0)
            + ?retail * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'retail'),0)
            + ?recreation * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'recreation'),0)
            + ?transit * COALESCE((SELECT score_original FROM generated.sa_overall_scores WHERE score_id = 'transit'),0)
        ) /
        (
            ?people + ?opportunity
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE doctors_high_stress > 0)
                    THEN ?core_services
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE dentists_high_stress > 0)
                    THEN ?core_services
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE hospitals_high_stress > 0)
                    THEN ?core_services
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE pharmacies_high_stress > 0)
                    THEN ?core_services
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE supermarkets_high_stress > 0)
                    THEN ?core_services
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE social_services_high_stress > 0)
                    THEN ?core_services
                ELSE 0
                END
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE retail_high_stress > 0)
                    THEN ?retail
                ELSE 0
                END
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE parks_high_stress > 0)
                    THEN ?recreation
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE trails_high_stress > 0)
                    THEN ?recreation
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE community_centers_high_stress > 0)
                    THEN ?recreation
                ELSE 0
                END
            +   CASE
                WHEN EXISTS (SELECT 1 FROM generated.sa_pop_grid WHERE transit_high_stress > 0)
                    THEN ?transit
                ELSE 0
                END
        ),
        NULL;

-- normalize
UPDATE  generated.sa_overall_scores
SET     score_normalized = score_original * ?total;

-- population
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT  'population_total',
        (
            SELECT SUM(partial_p) FROM generated.sa_pop_grid
            WHERE   EXISTS (
                        SELECT  1
                        FROM    received.sa_boundary AS b
                        WHERE   ST_Intersects(b.geometry,generated.sa_pop_grid.geometry)
                    )
        ),
        'Total population of boundary';


-- high and low stress total mileage
INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT 'total_km_low_stress',
    (
        SELECT
            (
                SUM(ST_Length(ST_Intersection(w.geom, b.geometry)) *
                    CASE ft_seg_stress WHEN 1 THEN 1 ELSE 0 END) +
                SUM(ST_Length(ST_Intersection(w.geom, b.geometry)) *
                    CASE tf_seg_stress WHEN 1 THEN 1 ELSE 0 END)
            ) / 1000 as dist
        FROM received.sa_ways as w, received.sa_boundary as b
        WHERE ST_Intersects(w.geom, b.geometry)
    ),
    'Total low-stress km';

INSERT INTO generated.sa_overall_scores (
    score_id, score_original, human_explanation
)
SELECT 'total_km_high_stress',
    (
        SELECT
            (
                SUM(ST_Length(ST_Intersection(w.geom, b.geometry)) *
                    CASE ft_seg_stress WHEN 3 THEN 1 ELSE 0 END) +
                SUM(ST_Length(ST_Intersection(w.geom, b.geometry)) *
                    CASE tf_seg_stress WHEN 3 THEN 1 ELSE 0 END)
            ) / 1000 as dist
        FROM received.sa_ways as w, received.sa_boundary as b
        WHERE ST_Intersects(w.geom, b.geometry)
    ),
    'Total high-stress km';

UPDATE generated.sa_overall_scores
SET    score_normalized = ROUND(score_original, 1)
WHERE  score_id in ('total_km_low_stress', 'total_km_high_stress');

SELECT * FROM generated.sa_overall_scores
```

## Results 

The overall results obtained include the final score for the whole city, as well as the score per destination category. The total population and stress network is also calculated. The results can be observed on the following table. 

```{r, echo = FALSE, warning = FALSE}
bna_display <- bna_score_table

bna_display$category <- c(
  "Total People",
  "Employment",
  "K-12 Education",
  "Technical/vocational school",
  "Higher Education",
  "Total Opportunity",
  "Doctor offices/clinics",
  "Dentist offices",
  "Hospitals",
  "Pharmacies",
  "Supermarkets",
  "Social services",
  "Total Core Services",
  "Total Retail shopping",
  "Parks",
  "Recreational trails",
  "Community centers",
  "Total Recreation",
  "Total Transit",
  "Overall Score",
  "Population",
  "Length of Low Stress Network (km)",
  "Length of High Stress Network (km)"
)

bna_display$id <- NULL
bna_display$score_id <- NULL

bna_display$score <- bna_display$score_normalized
bna_display[21,5] <- round(bna_display[21,1],0)

bna_display$score_original <- NULL
bna_display$score_normalized <- NULL

bna_display <- bna_display[c(20:23,1:19),]
row.names(bna_display) <- NULL

bna_display <- bna_display %>% mutate(
  category = cell_spec(
    category,
    bold = ifelse(
      grepl("Total",category),
      T, 
      F
    )
  ),
  score = cell_spec(
    score,
    "html", 
    color = ifelse(
      score >= 54 & score < 100,
      "#009acd",
      ifelse(
        score < 54,
        "#ff3030",
        "#666666"
        )
    )
  )
)

colnames(bna_display) <- c("popover","","Score/Value")

kable(
  bna_display[2:3], 
  align = c("l","r"), 
  format = "html", 
  escape = F
) %>% 
   kable_styling(
     "hover",
     full_width = FALSE,
     position = "center"
  ) %>% 
  group_rows("People", 5, 5) %>% 
  group_rows("Opportunity", 6, 10) %>% 
  group_rows("Core Services", 11, 17) %>% 
  group_rows("Retail", 18, 18) %>%
  group_rows("Recreation", 19, 22) %>% 
  group_rows("Transit", 23, 23)
```

We can plot the results to have a quick view of the output, including the high and low stress network in an interactive way. 

```{r, warning = FALSE}
library(sf)
bna_score <- st_read(
  dsn = connection,
  layer = c("generated","sa_pop_grid")
)

stress_network <- st_read(
  dsn = connection,
  query = "SELECT ft_seg_stress, tf_seg_stress, geom FROM received.sa_ways"
)
```

```{r, fig.width = 8, fig.height= 8,  echo = TRUE, warning = FALSE}
bna_pal <- c("#FC7151","#DC7E6A","#C98875","#C08B83","#AD9396",
             "#9C9A9F","#929EAC","#78AAC5","#6FADCB","#49BFE6")

bna_breaks <- c(6,12,18,24,30,36,42,48,54,100)

stress_network$ft_stress <- ifelse(stress_network$ft_seg_stress == 1,"low stress","high stress")
stress_network$tf_stress <- ifelse(stress_network$tf_seg_stress == 1,"low stress","high stress")

library(tmap)
tmap_mode("view")
int_map <- 
  tmap::tmap_leaflet(
     tmap::tm_view(
     basemaps = c(
       "CartoDB.Positron",
       "CartoDB.DarkMatter",
       "OpenStreetMap.Mapnik"
     )
   ) +
     tmap::tm_shape(bna_score) +
     tmap::tm_polygons(
       col = "overall_score",
       style = "fixed",
       breaks = bna_breaks,
       palette = bna_pal,
       alpha = 0.8,
       title = "BNA score",
       border.col = NULL,
       colorNA = NULL,
       showNA = FALSE
      ) +
     tmap::tm_shape(stress_network) +
     tmap::tm_lines(
       col = "ft_stress", 
       colorNA = NULL,
       showNA = FALSE,
       palette = c("firebrick1", "deepskyblue3"),
       title.col = "Stress network"
      ) +
     tmap::tm_shape(stress_network) +
     tmap::tm_lines(
       col = "tf_stress", 
       colorNA = NULL,
       showNA = FALSE,
       palette = c("firebrick1", "deepskyblue3"),
       legend.col.show = FALSE
      )
  )

int_map
```

## Observations

```{r, echo = FALSE, warning = FALSE, include = FALSE}
end <- Sys.time()

duration <- end - start

duration

dbDisconnect(connection)
```

* The total time that this particular city took to compute its BNA, including plots, overpass download, but without `GEOSTAT` data download on system, upload on file, and processing on database was **`r round(as.numeric(duration),2)` minutes**. Adding the `GEOSTAT` processing to the workflow adds around 5 minutes. Of course this is also subject to internet speed and computer performance. I run my analysis on an Asus F541U, Intel Core i7, 8GB RAM and 256 GB SSD, with Windows 10 OS.

* What can be observed for the whole analysis is that the resulting BNA score is highly influenced by the fact that the job/employment data was not included yet. However, this was an attempt to reproduce the score as close as possible as PfB apply their methodology, just to explore its reproducibility. 

* My plan next is to exclude this variable from the BNA score computation, and perhaps include some other variables that would suit the European context better. 

* My final goal for the moment is to try to validate the scoring methodology for Europe. I picked a city in the UK as I know there is Origin-Destination data available that could be used as a validation method. 
